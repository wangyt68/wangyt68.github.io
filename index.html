<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>我的学习笔记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="我的学习笔记">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="我的学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="王云涛">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="我的学习笔记" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">我的学习笔记</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-统计建模：分类性能评价（混淆矩阵和ROC曲线）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/20/%E7%BB%9F%E8%AE%A1%E5%BB%BA%E6%A8%A1%EF%BC%9A%E5%88%86%E7%B1%BB%E6%80%A7%E8%83%BD%E8%AF%84%E4%BB%B7%EF%BC%88%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5%E5%92%8CROC%E6%9B%B2%E7%BA%BF%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2021-06-20T02:59:04.000Z" itemprop="datePublished">2021-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/20/%E7%BB%9F%E8%AE%A1%E5%BB%BA%E6%A8%A1%EF%BC%9A%E5%88%86%E7%B1%BB%E6%80%A7%E8%83%BD%E8%AF%84%E4%BB%B7%EF%BC%88%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5%E5%92%8CROC%E6%9B%B2%E7%BA%BF%EF%BC%89/">统计建模：分类性能评价（混淆矩阵和ROC曲线）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><em>在数据本身严重有偏的情况下，准确率很容易达到一个很高的数值，因此需要寻找另外的性能评价方法。</em></p>
<h2 id="混淆矩阵"><a href="#混淆矩阵" class="headerlink" title="混淆矩阵"></a>混淆矩阵</h2><p><strong>混淆矩阵：将数据按待分的类别分组后，统计各组中模型分类或预测结果的矩阵</strong><br><img src="https://img-blog.csdnimg.cn/20200112201912818.png" alt="二分类"></p>
<ul>
<li><p>总例数：$\small{Total = TP + FP + FN + TN}$</p>
</li>
<li><p>准确率：$\small{ACC} = \frac{TP+TN}{Total}$</p>
</li>
<li><p>TPR or Sen = $\frac{TP}{TP +FN}$ （真阳性率、召回率、敏感性、检出率）<br>取值 [ 0，1 ] 越接近 1 性能越好</p>
</li>
<li><p>TNR or Spe = $\frac{TN}{FP +TN}$ （真阴性率、特异性、选择性）<br>取值 [ 0，1 ] 越接近 1 性能越好</p>
</li>
<li><p>PPV or precision = $\frac{TP}{TP +FP}$ （精度、阳性预测值）<br>取值 [ 0，1 ] 越接近 1 性能越好</p>
</li>
<li><p>NPV = $\frac{TN}{TN +FN}$ （阴性预测值）</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">mport pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> stats</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">iris = datasets.load_iris()    <span class="comment">#可直接获取鸢尾花数据集</span></span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>,<span class="number">15</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    <span class="built_in">print</span>(n)</span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        x=(iris.data[m*<span class="number">50</span>:m*<span class="number">50</span>+<span class="number">50</span>,n]-iris.data[m*<span class="number">50</span>:m*<span class="number">50</span>+<span class="number">50</span>,n].mean()) / iris.data[m*<span class="number">50</span>:m*<span class="number">50</span>+<span class="number">50</span>,n].std()</span><br><span class="line">        plt.subplot(<span class="number">4</span>, <span class="number">3</span>, n*<span class="number">3</span> + m + <span class="number">1</span>)</span><br><span class="line">        stats.probplot(x, dist=<span class="string">&#x27;norm&#x27;</span>, plot=plt)</span><br><span class="line">        </span><br><span class="line">        plt.text(-<span class="number">2</span>,<span class="number">2</span>,iris.feature_names[n])</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            plt.title(iris.target_names[m])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            plt.title(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        plt.xlim([-<span class="number">2.5</span>,<span class="number">2.5</span>])</span><br><span class="line">        plt.ylim([-<span class="number">2.5</span>,<span class="number">2.5</span>])</span><br><span class="line">        plt.plot([-<span class="number">2.5</span>,<span class="number">2.5</span>],[-<span class="number">2.5</span>,<span class="number">2.5</span>],c=<span class="string">&#x27;g&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">X_train, X_test, Y_train, Y_test = train_test_split(iris.data, iris.target,test_size=<span class="number">0.2</span>,random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> GaussianNB</span><br><span class="line">clf=GaussianNB()</span><br><span class="line">clf.fit(X_train, Y_train)</span><br><span class="line">y_pred=clf.predict(X_test)</span><br><span class="line"></span><br><span class="line">Y = pd.DataFrame(np.transpose([Y_test, y_pred]), columns=&#123;<span class="string">&#x27;true_type&#x27;</span>,<span class="string">&#x27;predict_type&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line"><span class="built_in">print</span>(confusion_matrix(y_pred, Y_test))</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report</span><br><span class="line"><span class="built_in">print</span>(classification_report(y_pred, Y_test))</span><br></pre></td></tr></table></figure>

<h2 id="线性二分类（ROC曲线进行评价）"><a href="#线性二分类（ROC曲线进行评价）" class="headerlink" title="线性二分类（ROC曲线进行评价）"></a>线性二分类（ROC曲线进行评价）</h2><ul>
<li>可以就参数的区分性能做专门评价</li>
<li>ROC曲线（接收者操作特征曲线）</li>
<li>绘制方法：对同样的测试集，改变线性划分的阈值，随着阈值的改变，分类的敏感性和特异性都会改变，以敏感性为纵坐标，1-特异性为横坐标，将选取不同阈值的结果在图中以散点画出，散点连成的曲线就是ROC曲线。</li>
<li>ROC曲线越远离45度对角线，分类性能越好。</li>
<li>量化指标：采用曲线下面积 AUC，AUC $\in$ [ 0，1 ]<br>越靠近 1，参数线性区分性能越好；靠近 0.5 时，接近随机划分；小于 0.5 时，分类倒置。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/20/%E7%BB%9F%E8%AE%A1%E5%BB%BA%E6%A8%A1%EF%BC%9A%E5%88%86%E7%B1%BB%E6%80%A7%E8%83%BD%E8%AF%84%E4%BB%B7%EF%BC%88%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5%E5%92%8CROC%E6%9B%B2%E7%BA%BF%EF%BC%89/" data-id="ckq4lq27n0001v8up20gga0p8" data-title="统计建模：分类性能评价（混淆矩阵和ROC曲线）" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-统计建模：朴素贝叶斯模型" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/20/%E7%BB%9F%E8%AE%A1%E5%BB%BA%E6%A8%A1%EF%BC%9A%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A8%A1%E5%9E%8B/" class="article-date">
  <time class="dt-published" datetime="2021-06-20T02:58:53.000Z" itemprop="datePublished">2021-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/20/%E7%BB%9F%E8%AE%A1%E5%BB%BA%E6%A8%A1%EF%BC%9A%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A8%A1%E5%9E%8B/">统计建模：朴素贝叶斯模型</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>贝叶斯定理：$P(C|x) = \frac{P(x|C)P(C)}{P(x)}$</p>
<ul>
<li>x：观察变量</li>
<li>C：一个潜在特性</li>
<li>$P(C|x)$：后验概率</li>
<li>$P(C)$：先验概率</li>
<li>$P(x|C)$：似然性 likelihood</li>
</ul>
<p>贝叶斯分类：最大化后验概率策略<br>对于具备 n 个特征的观测值 $x=(x_1,x_2, …,x_n)$，属于第 k 个分类的概率记为：</p>
<p>$P(C_k|x) = P(C_k|x_1,x_2,…,x_n)$</p>
<p>若特征间相互独立，则</p>
<p>$P(x_i|x_{i+1},…,x_n,C_k) = P(x_i|C_k)$</p>
<p>$P(x|C_k)P(C_k) = P(x_1|C_k)P(x_2|C_k) …P(x_n|C_k)P(C_k)$</p>
<p>总体中 x 的发生概率是不变的，所以只需要寻找使分子最大的类别即可。因此朴素贝叶斯模型的关键在于计算第 k 类在总体中的先验概率以及第 k 类中观察到 X 时的条件概率。<br>模型|描述|构建模型的函数<br>-|-|-<br>高斯模型|在每一个中都服从高斯分布（正太分布）的连续值|sklearn.native_bayes.GaussianNB<br>Multinomial（多项式）模型|$x_i$：特征 $i$ 发生的频次； $x$：n个特征的直方图|sklearn.native_bayes.MultinomiaNB<br>Bernoulli（伯努利）模型|$x_i$：特征 $i$ 发生 / 不发生； $x$：n 个特征发生与否的二进制序列|sklearn.native_bayes.BernoulliNB</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/20/%E7%BB%9F%E8%AE%A1%E5%BB%BA%E6%A8%A1%EF%BC%9A%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A8%A1%E5%9E%8B/" data-id="ckq4lq27o0002v8up87hy1612" data-title="统计建模：朴素贝叶斯模型" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-统计建模：Logistic回归模型（逻辑回归）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/20/%E7%BB%9F%E8%AE%A1%E5%BB%BA%E6%A8%A1%EF%BC%9ALogistic%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B%EF%BC%88%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2021-06-20T02:57:36.000Z" itemprop="datePublished">2021-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/20/%E7%BB%9F%E8%AE%A1%E5%BB%BA%E6%A8%A1%EF%BC%9ALogistic%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B%EF%BC%88%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%EF%BC%89/">统计建模：Logistic回归模型（逻辑回归）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Logistic回归（逻辑回归）：用量化特征预测某事发生的概率，取值范围是0到1，多用于二分类问题。</p>
<p>$f = \frac{1}{1 + e^{-t}}$<br><img src="https://img-blog.csdnimg.cn/20200112153157115.png" alt="在这里插入图片描述"></p>
<ul>
<li>输入t：样本特征中的线性函数</li>
<li>几率（Odds）：设某事件发生的概率为 P，则该事件的几率为该事件发生的概率与不发生的概率之比<br>$Odds = \frac{P}{1 - P}\qquad \small Odds\in [ 0，+\infty)$</li>
<li>可基于样本的特征构建线性函数，函数值对应时间的对数几率 $\quad log_e(\frac{P}{1-P}) = \beta_0 +\beta_1x\quad$其值域为$;\small(- \infty,+\infty)$</li>
</ul>
<p>bikeshare数据集：<a target="_blank" rel="noopener" href="http://archive.ics.uci.edu/ml/datasets/Bike+Sharing+Dataset">http://archive.ics.uci.edu/ml/datasets/Bike+Sharing+Dataset</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">table = pd.DataFrame(&#123;<span class="string">&#x27;prob&#x27;</span>:[<span class="number">0.01</span>,<span class="number">0.2</span>,<span class="number">0.3</span>,<span class="number">0.4</span>,<span class="number">0.5</span>,<span class="number">0.6</span>,<span class="number">0.7</span>,<span class="number">0.8</span>,<span class="number">0.9</span>,<span class="number">0.99</span>]&#125;)</span><br><span class="line">table[<span class="string">&#x27;odds&#x27;</span>]=table[<span class="string">&#x27;prob&#x27;</span>]/(<span class="number">1</span>-table[<span class="string">&#x27;prob&#x27;</span>])</span><br><span class="line">table[<span class="string">&#x27;log-odds&#x27;</span>]=np.log(table[<span class="string">&#x27;odds&#x27;</span>])</span><br><span class="line">plt.plot(table[<span class="string">&#x27;prob&#x27;</span>],<span class="string">&#x27;g&#x27;</span>)</span><br><span class="line">plt.plot(table[<span class="string">&#x27;odds&#x27;</span>],<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">plt.plot(table[<span class="string">&#x27;log-odds&#x27;</span>],<span class="string">&#x27;m&#x27;</span>)</span><br><span class="line">plt.legend(&#123;<span class="string">&#x27;probability&#x27;</span>, <span class="string">&#x27;Odds&#x27;</span>, <span class="string">&#x27;log_odds&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">plt.ylim(-<span class="number">6</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p>$P = \frac{e^{\beta_0+\beta_1x}}{1 + e^{\beta_0+\beta_1x}}$</p>
<ul>
<li>Logistic回归就是对几率作线性回归</li>
<li>优化准则：极大化所有样本的对数似然函数</li>
<li>对于非数值型数据：使用 one-hot 编码</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> stats</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bikes= pd.read_csv(<span class="string">&#x27;E:\my_data\\bikeshare\hour.csv&#x27;</span>)feature_cols=[<span class="string">&#x27;temp&#x27;</span>]</span><br><span class="line"></span><br><span class="line">x=bikes[feature_cols]</span><br><span class="line">bikes[<span class="string">&#x27;above_average&#x27;</span>]=bikes[<span class="string">&#x27;cnt&#x27;</span>]&gt;=bikes[<span class="string">&#x27;cnt&#x27;</span>].mean()</span><br><span class="line">y=bikes[<span class="string">&#x27;cnt&#x27;</span>]&gt;=bikes[<span class="string">&#x27;cnt&#x27;</span>].mean()</span><br><span class="line"></span><br><span class="line">x_train, x_test, y_train, y_test=train_test_split(x, y)</span><br><span class="line">logreg=LogisticRegression()</span><br><span class="line">logreg.fit(x_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(pd.DataFrame(np.transpose([y_test.values, logreg.predict(x_test)]), columns =&#123;<span class="string">&#x27;真实值&#x27;</span>,<span class="string">&#x27;预测值&#x27;</span>&#125;))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;分类准确率是：&#x27;</span>, logreg.score(x_test, y_test))</span><br><span class="line"></span><br><span class="line">when_dummies=pd.get_dummies(bikes[<span class="string">&#x27;season&#x27;</span>],prefix=<span class="string">&#x27;season_&#x27;</span>)</span><br><span class="line">when_dummies=when_dummies.iloc[:,<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">new_bikes=pd.concat([bikes[<span class="string">&#x27;temp&#x27;</span>], when_dummies],axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">x = new_bikes</span><br><span class="line">x_train, x_test, y_train, y_test=train_test_split(x, y)</span><br><span class="line">logreg=LogisticRegression()</span><br><span class="line">logreg.fit(x_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;用气温、季节作为预测自变量，预测的准确率是：&#x27;</span>, logreg.score(x_test, y_test))</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/20/%E7%BB%9F%E8%AE%A1%E5%BB%BA%E6%A8%A1%EF%BC%9ALogistic%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B%EF%BC%88%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%EF%BC%89/" data-id="ckq4lq27i0000v8up122b9sbe" data-title="统计建模：Logistic回归模型（逻辑回归）" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-数据建模：统计分析概述" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/20/%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1%EF%BC%9A%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E6%A6%82%E8%BF%B0/" class="article-date">
  <time class="dt-published" datetime="2021-06-20T02:50:48.000Z" itemprop="datePublished">2021-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/20/%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1%EF%BC%9A%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E6%A6%82%E8%BF%B0/">数据建模：统计分析概述</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><del><em>本文为学习黄晓林老师开设的慕课《探索数据的奥秘》所作笔记</em></del> </p>
<h2 id="数据科学简介"><a href="#数据科学简介" class="headerlink" title="数据科学简介"></a>数据科学简介</h2><p><code>现时代科学范式正在转变，继实验、理论与计算之后，数据科学已成为人类探索世界的第四科学范式。工业界对数据科学的关注在应用层面，更关注相关性而非因果性。</code></p>
<h4 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h4><p>数据传感器采集到的各种物理、生物、化学指标等等可记录、可表征的数量、性质都是数据，对于行为的描述与记录也能构成数据，例如互联网上的一次次交易，访问。总之，现实中某种事物或事物间关系数量或性质的表征和记录，都称之为数据，数据是信息的载体。</p>
<h4 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h4><p>有观点认为，当数据量大到需要使用并行计算工具处理时，就称之为大数据（Big Data）。通常认为大数据有4V特点，即体量大（High Volume）、速度快时效高（High Velocity）、类型繁多（High Variety）、价值密度低（High Veracity）</p>
<p>1993年，美国学者挨个拉沃提出了Aprior算法，可以通过分析购物篮中的商品几何，找出商品间关系，然后研究或推测顾客的购买行为，沃尔玛将其引入pos机数据分析，发现一些看似毫无关联的商品，例如啤酒和尿布经常出现在同一购物车中，即两者具有相关性。</p>
<h4 id="数据科学"><a href="#数据科学" class="headerlink" title="数据科学"></a>数据科学</h4><p>应用科学的方法、流程、算法和系统从多种形式的结构化或非结构化数据中提取知识和洞见的交叉学科。所有对数据的搜集，存储，分类，处理，分析，呈现都可纳入数据科学的范畴。</p>
<h4 id="数据科学项目克可能涉及的人员："><a href="#数据科学项目克可能涉及的人员：" class="headerlink" title="数据科学项目克可能涉及的人员："></a>数据科学项目克可能涉及的人员：</h4><table>
<thead>
<tr>
<th>人员</th>
<th>定位</th>
</tr>
</thead>
<tbody><tr>
<td>项目出资方</td>
<td>商业利益，提供项目支持</td>
</tr>
<tr>
<td>客户（或用户）</td>
<td>最终用户利益（领域专家）</td>
</tr>
<tr>
<td>数据架构师</td>
<td>管理数据和数据存储</td>
</tr>
<tr>
<td>运营工程师</td>
<td>管理基础设施和部署最终成果</td>
</tr>
<tr>
<td>数据科学家（核心人员）</td>
<td>设定和执行分析战略</td>
</tr>
</tbody></table>
<h2 id="一、明确问题及制定目标"><a href="#一、明确问题及制定目标" class="headerlink" title="一、明确问题及制定目标"></a>一、明确问题及制定目标</h2><p>用户层面<br>针对用户的具体问题，应做好充足的背景调查，从而制定出相应的用户层面的目标。<br>数据科学层面：可将问题抽象为分类、预测、排名或打分、关联化、特征提取、聚类等。<br>类型|描述<br>-|-<br>分类|对于给定的数据，依据一定的规则进行两个或两个以上的类别划分，输出为针对输入的数据所分配的类别标签。例如：真/假，类别A / 类别B / 类别C /……<br>预测|基于一直数据对将来的状态作出估计或判断，输出为连续的数量值或类别标签<br>排名 (打分)|对于实体的某种属性或响应进行数量化描述或进行排序<br>关联化 去关联化|在尸体的众多特征种，寻找有相互关联的特征以便相互替代，从而实现特征的相互“解释”或数据降维；而对于非关联的特征则需予以保留以实现对样本的全面描述<br>特征提取|基于实体的众多特征，构造最反应目标的，或最能知识某种分类的复合特征<br>聚类|根据样本间的相似度将样本分组</p>
<h2 id="二、数据搜集与准备"><a href="#二、数据搜集与准备" class="headerlink" title="二、数据搜集与准备"></a>二、数据搜集与准备</h2><h4 id="前提假设和数据构成"><a href="#前提假设和数据构成" class="headerlink" title="前提假设和数据构成"></a>前提假设和数据构成</h4><p>明确必要的前提假设，基于假设的前提来设计数据的构成，明确总体和抽样方案再搜集数据。</p>
<p>在面向实际应用时，始终不能忘记方案的可行性分析，不同的假设很可能会涉及不同的数据，最终导致不同的研究内容。因此，在真正进行数据搜集之前，应认真审视与事实最符合的假设，根据最符合事实的假设提出对应的数据方案，思考方案的可行性，确定数据的构成。</p>
<p>通常，后续方便处理的数据是 ” 结构化 “ 的数据（可将其抽象的理解为一张二维表，一行对应一个样本，一列对应一个属性）</p>
<h4 id="总体和抽样"><a href="#总体和抽样" class="headerlink" title="总体和抽样"></a>总体和抽样</h4><p>总体（Population）：待研究对象的全体<br>个体（Individual）：总体中的每一个对象<br>样本：在无法获得总体的情况下，从总体中抽取出来的子集<br>样本容量：样本包含的个体数量</p>
<ul>
<li>数据收集是一种从总体中抽样的过程</li>
<li>样本容量不能太小，传统统计学认为小于30的样本容量不具备统计学意义</li>
<li>抽样时不能有预设偏见，也就是必须无偏抽样，即抽样的过程不受个体性质的影响。</li>
<li>抽样偏差指从总体中非随机型抽样带来的系统性错误，幸存者偏差就是一种常见的抽样偏差</li>
<li>避免抽样偏差常见的作法是随机抽样。随机抽样是指总体中的个体是否被抽样并非是确定的（即，不因为个体的某个或某些性质一定被抽中或一定不被抽中），而是以一定的概率被抽样</li>
</ul>
<h4 id="混杂因素和A-B-Testing"><a href="#混杂因素和A-B-Testing" class="headerlink" title="混杂因素和A/B Testing"></a>混杂因素和A/B Testing</h4><p><strong>辛普森悖论：</strong> 人们尝试探究两种变量（比如新生录取率与性别）是否具有相关性的时候，会分别对之进行分组研究。然而，在分组比较中都占优势的一方，在总评中有时反而是失势的一方。<br><strong>常见的排除混杂因素影响的做法：</strong> 对两相比较的样本集，做好潜在混杂因素（甚至所有非考察因素）的匹配。</p>
<ul>
<li>对于关联任务而言，混杂因素的排除是关键</li>
</ul>
<p><strong>A/B Testing：</strong> 指专门设计一些对比试验，在其他所有特征都匹配（或一致）的情况下，只观察一个变量的不同取值对于结果的影响。科学研究中，在实验室的可控环境下，A/B Testing 是一种非常常见的实验手段，例如 “ 双盲实验 ” 。主动搜集数据时，A/B Testing 是一种可靠而有效的方式。</p>
<h2 id="三、使用python进行数据导入"><a href="#三、使用python进行数据导入" class="headerlink" title="三、使用python进行数据导入"></a>三、使用python进行数据导入</h2><p><strong>NumPy.load_txt()</strong></p>
<ul>
<li>将指定文件中的数据加载到数组</li>
<li>支持纯文本文件，如 txt 文件和 csv 文件</li>
<li>返回 NumPy 的 ndarray 多维数组</li>
<li>一般用来加载数据类型一直的数据文件<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.loadtxt(<span class="string">&#x27;E:\my_data.csv&#x27;</span>, delimiter=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"><span class="comment">#查看导入数据的规模</span></span><br><span class="line"><span class="built_in">print</span>(x.shape)	</span><br><span class="line"><span class="comment">#ndarray的二维切取</span></span><br><span class="line">x[:<span class="number">2</span>,:<span class="number">3</span>]	</span><br><span class="line"><span class="comment">#指定导入的数据类型为int</span></span><br><span class="line">x_int = np.loadtxt(<span class="string">&#x27;E:\my_data.csv&#x27;</span>, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="built_in">int</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>Pandas.read_csv()</strong></p>
<ul>
<li>面对数据并不统一的电子表格数据</li>
<li>将电子表格文件中的数据导入到 Pandas 的 DataFrame 结构（二维表格结构）</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment">#header=None表示没有表头</span></span><br><span class="line"><span class="comment">#names参数：为表格的各列设置列标题</span></span><br><span class="line">data = pd.read_csv(<span class="string">&#x27;E:\my_data.csv,</span></span><br><span class="line"><span class="string">	header=None, names=[&#x27;</span>A<span class="string">&#x27;,&#x27;</span><span class="string">B&#x27;,&#x27;</span>C<span class="string">&#x27;,&#x27;</span>D<span class="string">&#x27;,&#x27;</span>E<span class="string">&#x27;])</span></span><br><span class="line"><span class="string">#可以使用data.values访问表格中存放的数据，为ndarray类型</span></span><br><span class="line"><span class="string">print(data.values)</span></span><br></pre></td></tr></table></figure>
<p><strong>Python自带模块urllib 可用于网上在线获取文件</strong></p>
<ul>
<li>urllib.request.urlopen()</li>
</ul>
<p><strong>CountVectorizer实现非结构化数据转化为结构化数据</strong><br>非结构化数据一般通过结构化处理使其成为表格，方便后续的分析与建模</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用fetch_20newsgroups函数可以自动下载数据到 </span></span><br><span class="line"><span class="comment">#[Currentuser]\scikit_learn_data 下面</span></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> fetch_20newsgroups</span><br><span class="line"><span class="comment">#下载医学新闻数据集</span></span><br><span class="line">my_news=fetch_20newsgroup(categories[<span class="string">&#x27;sci.med&#x27;</span>]) </span><br><span class="line"><span class="built_in">print</span>(twenty_sci_news_data[<span class="number">0</span>], <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#CountVectorizer是属于常见的特征数值计算类，是一个文本特征提取方法</span></span><br><span class="line"><span class="comment">#对于每一个训练文本，它只考虑每种词汇在该训练文本中出现的频率。</span></span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> CountVectorizer</span><br><span class="line">count_vect=CountVectorizer()</span><br><span class="line"><span class="comment">#通过fit_transform函数计算各个词语出现的次数，返回一个稀疏矩阵对象</span></span><br><span class="line">word_count=count_vect.fittransform(my_news.data)	</span><br></pre></td></tr></table></figure>

<p><strong>对大规模数据的读取</strong></p>
<ul>
<li><p>以连续流的方式流入，而非一次性加载</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pands <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment">#规定chunksize后返回的数据类型不再是DataFrame</span></span><br><span class="line"><span class="comment">#而是一个可迭代的TextFileReader对象</span></span><br><span class="line"><span class="comment">#它保存了若干个chunk的尺寸和位置</span></span><br><span class="line"><span class="comment">#但只有当被迭代器指到时，才会真正把对应的数据读入内存</span></span><br><span class="line">my_chunk=pd.read_csv(<span class="string">&#x27;E:\my_data.csv&#x27;</span>, header=<span class="literal">None</span>,</span><br><span class="line">				names=[<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>],</span><br><span class="line">				chunksize=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n,chunk <span class="keyword">in</span> <span class="built_in">enumerate</span>(my_chunk):</span><br><span class="line">	<span class="built_in">print</span>(chunk.shape)</span><br><span class="line">	<span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">		<span class="built_in">print</span>(chunk)	<span class="comment">#每一个chunk都是一个DataFrame</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">#get_chunk()方法是当前位置获取指定大小的数据块</span></span><br><span class="line">	<span class="comment">#会改变迭代器指针</span></span><br><span class="line">	<span class="comment">#if n &lt;= 2:</span></span><br><span class="line">	<span class="comment">#	print(my_chunk.get_chunk(1),&#x27;\n&#x27;)</span></span><br></pre></td></tr></table></figure></li>
<li><p>csv 包中的 reader 函数和 DictReader 函数 可以实现小块数据的迭代</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="comment">#with命令保证以下代码执行完后文件会关闭</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;E:\my_data.csv&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> my_data_stream:</span><br><span class="line"><span class="comment">#用csv.reader读取文件，一次读取一行，作为列表对象</span></span><br><span class="line">	my_reader=csv.reader(my_data_stream,dialect=<span class="string">&#x27;excel&#x27;</span>)</span><br><span class="line">	<span class="keyword">for</span> n,row <span class="keyword">in</span> enumrate(my_reader)<span class="string">&quot;</span></span><br><span class="line"><span class="string">	if n &lt;= 5:</span></span><br><span class="line"><span class="string">		print(row, &#x27;\n&#x27;)</span></span><br><span class="line"><span class="string">		</span></span><br></pre></td></tr></table></figure>

<h2 id="四、探索性数据分析（EDA）"><a href="#四、探索性数据分析（EDA）" class="headerlink" title="四、探索性数据分析（EDA）"></a>四、探索性数据分析（EDA）</h2><ul>
<li>初步了解数据集</li>
<li>验证初步假设</li>
</ul>
<p> <strong>数据检查和预处理</strong></p>
<ul>
<li>数据检查 ：数据的规模与特征的数据类型及意义</li>
<li>预处理：缺失处理、异常处理、冗余处理</li>
</ul>
<p>数据的类型：数值型数据、字符型数据、逻辑型数据（bool型数据）、排序类型<br>（依据某个量度得到的，具备一定的量化意义）</p>
<p>对于数值型数据，可以用算术平均，标准差等量化统计量进行分析。<br>对于非数值型数据，主要依据它们进行分组与筛选。</p>
<p> <strong>数据的初步分析</strong></p>
<ol>
<li>缺失数据：用 NaN 表示</li>
</ol>
<ul>
<li>数据随机性缺失<ul>
<li>直接丢弃：dataframe.dropna函数（样本容量大，缺失信息少）</li>
<li>修补填充：dataframe.fillna函数（样本容量小，无法承受进一步缺失）    缺失值填充是一种止损手段，可以将原本不完整数据行中的其他信息利用起来，从而避免了有效信息的进一步损失。</li>
</ul>
</li>
<li>非随机性缺失：具体情况具体分析</li>
</ul>
<ol start="2">
<li>数据混则了噪声、干扰，甚至错误数据。应基于数据的实际意义，利用常识或专业领域知识进行判断。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my_dict=&#123;<span class="string">&#x27;A&#x27;</span>:<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;2&#x27;</span>&#125;	<span class="comment">#A列填充为1，B列填充为2</span></span><br><span class="line">my_fill_data3=my_data.fillna(my_dict)</span><br><span class="line"></span><br><span class="line">my_fill_data4=my_data.fillna(method=<span class="string">&#x27;ffill) #使用缺失值之前的邻近值进行填充</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">my_fill_data4=my_data.fillna(method=&#x27;</span>bfill) <span class="comment">#使用缺失值之后的邻近值进行填充</span></span><br></pre></td></tr></table></figure>
<ul>
<li>对于服从正态分布的数据：z-score<br>z-score 是个无量纲的数，可以消除数据本身的取值范围带来的影响。一般认为z-score &gt; 3 时，可以怀疑异常。</li>
<li>对于不服从正态分布的数据：四分位距<br>q1：第一个四分位数<br>q3：第三个四分位数<br>△ = q3 - q1：四分位距<br>x &gt; q3 + 3△ 或 x &lt; q1 - 3△：认为是极端异常值或离群值outlier</li>
<li>对于异常值</li>
</ul>
<table>
<thead>
<tr>
<th>情况</th>
<th>处理方法</th>
</tr>
</thead>
<tbody><tr>
<td>确定是出错的数据</td>
<td>丢弃或替换</td>
</tr>
<tr>
<td>不能肯定是错误</td>
<td>增加样本容量</td>
</tr>
<tr>
<td>3. 数据冗余</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>情况</th>
<th>处理方法</th>
</tr>
</thead>
<tbody><tr>
<td>数据列直接重复</td>
<td>直接通过列名称或特征名筛选</td>
</tr>
<tr>
<td>不同特征出现冗余</td>
<td>如果一个特征可以通过将另一个线性特征变换得到，那么这两个特征就是重复的，可以去掉一个。</td>
</tr>
<tr>
<td>判断特征冗余常用方法：线性相关分析</td>
<td></td>
</tr>
<tr>
<td>Dataframe.corr函数</td>
<td></td>
</tr>
<tr>
<td>当参数 method=‘pearson’ 时，直接求线性相关系数</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>线性相关系数接近 1 或 -1 ，则说明两个特征存在强的线性相关或反相关，有着较大的冗余</li>
<li>线性相关系数等于 0， 两个特征间没有线性相关性</li>
</ul>
<p><strong>描述性统计</strong><br>描述性统计不对数据做任何预先地猜想，实事求是地告诉我们样本数据是怎样的。在描述性的结果上进行思考可以形成一些初步的结论。</p>
<ul>
<li><strong>位置性测度计算</strong></li>
</ul>
<p>位置性测度主要用来反映样本集合的中心成员或特定成员在所考察的数域或空间的位置。只能针对数值数据计算。</p>
<table>
<thead>
<tr>
<th>常用的位置测度</th>
<th>定义</th>
<th>特点</th>
<th>函数</th>
</tr>
</thead>
<tbody><tr>
<td>算术平均（arithmetic mean）</td>
<td>对所有考察的样本值求统计平均</td>
<td>易受极端值影响</td>
<td>dataframe.mean()</td>
</tr>
<tr>
<td>中位数（median）</td>
<td>将所有样本按数值从小到大或从大到小排序后，最中间位置的一个数，或者两个数的平均</td>
<td>对极端值不敏感，但对中位数以外的所有值也都不敏感</td>
<td>dataframe.median()</td>
</tr>
<tr>
<td>p 百分位数（quantiles）</td>
<td>将所有样本值按从小到大的顺序拍好，排序在第 p% 的样本取值</td>
<td>第 p 个百分位数记为 Vp，则样本中有且仅有 p% 的观察值小于等于 Vp</td>
<td>dataframe.quantiles(q=0.25)</td>
</tr>
<tr>
<td>众数（mode）</td>
<td>样本集中出现次数最多的值</td>
<td>众数可能只有一个，也可能有多个</td>
<td>dataframe.mode()</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">常用的 p 百分位数：</span><br><span class="line">- 第10百分位数</span><br><span class="line">- 第25百分位数（第一四分位数）</span><br><span class="line">- 第50百分位数（中位数）</span><br><span class="line">- 第75百分位数（第三四分位数）</span><br><span class="line">- 第90百分位数</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>离散性测度计算</strong><br>只能针对数值数据计算</li>
</ul>
<table>
<thead>
<tr>
<th>常用离散性测度</th>
<th>描述</th>
<th>函数</th>
</tr>
</thead>
<tbody><tr>
<td>极差（range）</td>
<td>指集合中最大与最小值之间的差异，对极端值非常敏感</td>
<td>max() - min()</td>
</tr>
<tr>
<td>方差（variance）</td>
<td>对集合中所有样本值相对于均值的偏差的平方求近似平均</td>
<td>var()</td>
</tr>
<tr>
<td>标准差（Standard Deviation）</td>
<td>方差的平方根称为标准差，方差和标准差可以总体衡量集合中数据偏离均值的程度</td>
<td>std()</td>
</tr>
<tr>
<td>变异系数（coefficient of variation, CV）</td>
<td>无量纲，能尽量消除单位及均值的绝对位置带来的影响。</td>
<td>std() / mean()</td>
</tr>
</tbody></table>
<p>describe函数：对dataframe中所有用数值保存的特征（无论是整数还是浮点数），一次性计算多个常用的描述性统计量</p>
<ul>
<li><strong>图形化描述</strong><br>既适用于数值型数据，也适用于非数值型数据的计算</li>
</ul>
<table>
<thead>
<tr>
<th>常用图形</th>
<th>描述</th>
<th>函数</th>
</tr>
</thead>
<tbody><tr>
<td>直方图</td>
<td>将数据分组，记录样本在每个组中出现的频数</td>
<td>hist函数</td>
</tr>
<tr>
<td>箱型图</td>
<td>通过几个重要的百分位数来界定数据的主要分布，下边缘为 q1，上边缘为 q3，箱子的中线代表中位数，箱子两端伸出的虚线用来刻画极差，超出上下边缘的被当作异常值或outlier离群点</td>
<td>boxplot函数</td>
</tr>
</tbody></table>
<ul>
<li><strong>非数值型的特征</strong><br>主要应用来分组，从而对各组进行频次统计，绘制与直方图类似的柱状图<br>利用 dataframe.groupby 函数进行分组</li>
</ul>
<ul>
<li><strong>两个数值型特征相结合</strong><br>简单的图形化方法为二维散点图，其绘制方法为： 用样本在一个特征上的取值作为横轴，在另一个要关联考察的特征上的取值作为纵轴，这样在二维平面上确定下该样本的位置，描绘出一个样本点。<br>可以采用 pandas.plotting.scatter_matrix 对两个数值型特征绘制散点图。</li>
</ul>
<h2 id="统计建模（统计推断）"><a href="#统计建模（统计推断）" class="headerlink" title="统计建模（统计推断）"></a>统计建模（统计推断）</h2><p>实质：由样本去推断总体的过程<br>主要包括：参数估计和假设检验</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> stats</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">1234</span>)</span><br><span class="line"><span class="comment">#生成一个规定均值的泊松分布</span></span><br><span class="line">my_data1=stats.poisson.rvs(loc=<span class="number">10</span>,mu=<span class="number">60</span>,size=<span class="number">3000</span>) </span><br><span class="line">pd.Series(my_data1).hist().get_figure().show</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_data2=stats.poisson.rvs(loc=<span class="number">10</span>,mu=<span class="number">15</span>,size=<span class="number">6000</span>) </span><br><span class="line">pd.Series(my_data2).hist().get_figure().show</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成一个典型的bi-mode分布，以这9000个数据作为总体</span></span><br><span class="line">my_data=np.comcatemate(my_data1, my_data2)</span><br><span class="line"><span class="comment">#随机抽取100个作为样本</span></span><br><span class="line">sample_data=np.random.choice(a=my_data,size=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">sample_size=<span class="number">100</span></span><br><span class="line">sample=np.random.choice(a=my_data,size=sample_size)</span><br><span class="line">sigma=sample.std()/(sample_size)**<span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">stats.t.interval(alpha=<span class="number">0.95</span>,	<span class="comment">#置信水平</span></span><br><span class="line">				df=sample_size-<span class="number">1</span>,</span><br><span class="line">				loc=sample.mean(),</span><br><span class="line">				scale=sigma)</span><br></pre></td></tr></table></figure>
<p><strong>假设检验</strong></p>
<ol>
<li>提出假设</li>
<li>验证是否可以接受假设</li>
</ol>
<p>零假设（null hypothesis）：H0，需要检验的假设，如：</p>
<ul>
<li>总体的均值等于μ</li>
<li>测试组和对照组来源于均值相等的总体</li>
<li>控制因素对观察变量有没有影响，A组和B组数据同分布</li>
</ul>
<p>替代假设（alternative hypothesis）：H1，某种程度上与 H0 相反的假设。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> t</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/20/%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1%EF%BC%9A%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E6%A6%82%E8%BF%B0/" data-id="ckq4lgm3h0000h4upddaz31g2" data-title="数据建模：统计分析概述" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Spring学习笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/25/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2021-05-25T03:02:01.000Z" itemprop="datePublished">2021-05-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/25/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Spring学习笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p>Spring 用于解决企业级框架的复杂性，适用于任何 java 应用</p>
<p>Spring是一个轻量级控制反转(IoC)和面向切面(AOP)的容器框架。</p>
<h2 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h2><p>2002, 首次推出Spring框架的雏形 interface 21<br>2004年3月24日, 以interface 21 为基础，经过重新设计正式发布Spring1.0版本<br>Rod Johnson Spring Framework创始人，音乐学博士</p>
<h2 id="Spring-理念"><a href="#Spring-理念" class="headerlink" title="Spring 理念"></a>Spring 理念</h2><ul>
<li><p>强大的向后兼容性 </p>
</li>
<li><p>代码标准质量高</p>
</li>
<li><p>使现有的技术更加容易使用，本身是一个大杂烩，整合了现有的技术框架。<br>SSH: Struct2 + Spring + Hibernate<br>SSM: SpringMVC + Spring + Mybatis</p>
</li>
</ul>
<p>官网: <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/overview.html#overview">https://docs.spring.io/spring-framework/docs/current/reference/html/overview.html#overview</a><br>官方下载地址<a target="_blank" rel="noopener" href="https://repo.spring.io/release/org/springframework/spring/">https://repo.spring.io/release/org/springframework/spring/</a><br>github: <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework">https://github.com/spring-projects/spring-framework</a></p>
<p><strong>优点</strong>：开源 免费 轻量级 非入侵式 控制反转(IOC) 面向切面编程（AOP） 支持事务的处理 对框架整合的支持</p>
<p><strong>组成</strong>：七模块 AOP ORM Context …</p>
<p>Spring发展太久后违背了原来的理念，配置十分繁琐。</p>
<p>SpringBoot旨在使用最小的配置启动应用</p>
<p>Spring Boot: 一个快速开发的脚手架，基于SpringBoot 可以快速的开发单个微服务，约定大于配置。</p>
<p>Spring Cloud: 是基于SpringBoot实现的</p>
<h2 id="Spring-的整体架构"><a href="#Spring-的整体架构" class="headerlink" title="Spring 的整体架构"></a>Spring 的整体架构</h2><p>Spring 是一个分层架构，包含一系列的功能要素，并被分为大约20个模块。</p>
<p>这些模块被总结为以下几部分：</p>
<ul>
<li>Core Container（核心容器）：包含有Core、Beans、Context和Expression Language模块。</li>
<li>Data Access/Integration：包含JDBC、ORM、OXM、JMS 和 Transaction模块。</li>
<li>Web：Web上下文模块建立在应用程序上下文模块之上，为基于Web的应用程序提供了上下文。包含Web、Web-Servlet、Web-Porlet模块。</li>
<li>AOP</li>
<li>Test</li>
</ul>
<h2 id="控制反转（IoC）"><a href="#控制反转（IoC）" class="headerlink" title="控制反转（IoC）"></a>控制反转（IoC）</h2><p>IoC（Inversion of Control，控制反转）是一种设计思想，而依赖注入（DI）是IOC的一种实现方式。</p>
<p>在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。</p>
<p>Spring 中实现IOC的是IOC容器，其实现方式是DI。</p>
<p><strong>谁控制谁，控制什么：</strong></p>
<p>传统Java  SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建。</p>
<p>IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。</p>
<p><strong>为何是反转，哪些方面反转了：</strong></p>
<p>有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；</p>
<p>为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。</p>
<p><strong>IOC（控制反转）理论推导示例</strong><br>UserDao 接口<br>UserDaoImpl 实现类<br>UserService 业务接口<br>UserServiceImpl 业务实现类</p>
<p>原来 Service中 new UserDaoImpl()，用户实际调用的是Service业务层，若想要增加一个新的UserDaoMysqlImpl实现类，需要修改Service中的new 代码。</p>
<p>使用IOC实现时，不需根据用户需求修改员来的代码。这里可以取消new，而使用set方法为 userDao 变量赋值。</p>
<p>之前程序主动创建对象，控制权在程序员手上，所以每当用户修改需求后都需要修改代码。使用set注入后，程序不再具有主动性，而是变为被动的接收对象。程序员不需要再去管理对象的创建，系统耦合性大大降低，可以专注在业务的实现上。这是IOC的原型。</p>
<p>使用面向对象编程：程序对象的依赖关系硬编码在程序中<br>控制反转：获得依赖对象的方式反转了</p>
<p><strong>IOC创建对象的方式</strong></p>
<ol>
<li>默认使用无参构造创建对象</li>
<li>使用有参构造函数时应使用<code>&lt;constructor-arg /&gt;</code>,如 <code>&lt;constructor-arg  index=&quot;0&quot; value=&quot;&quot; /&gt;</code>，或不使用index而是使用类型，参数名进行构造</li>
</ol>
<p>配置文件加载时，容器中管理的对象就已经初始化了。内存中只有一份实例，多次getBean取出的对象相同。</p>
<h3 id="Spring-IoC简介"><a href="#Spring-IoC简介" class="headerlink" title="Spring IoC简介"></a>Spring IoC简介</h3><p>Spring IoC通过一个配置文件买搜狐Bean和Bean之间的依赖关系，利用Java的反射功能实例化Bean并建立Bean之间的依赖关系。</p>
<p>Spring的Ioc容器为Spring Ioc，Spring IoC容器在完成这些底层工作的基础上，还提供了Bean实例缓存管理，Bean生命周期管理，Bean实例代理，事件发布和资源装载等高级服务。</p>
<p>Spring 提供了两种 IoC 容器，分别为 BeanFactory 和 ApplicationContext。</p>
<h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><p>BeanFactory 是基础类型的 IoC 容器，是一个管理 Bean 的工厂，它主要负责初始化各种 Bean，并调用它们的生命周期方法。</p>
<p>它有多个实现类，最常见的是 XmlBeanFactory，根据 XML 配置文件中的定义装配 Bean。</p>
<h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><p>ApplicationContext 是 BeanFactory 的子接口，也被称为应用上下文。</p>
<p>它不仅提供了 BeanFactory 的所有功能，还添加了对 i18n（国际化）、资源访问、事件传播等方面的良好支持。</p>
<p>ApplicationContext 接口有两个常用的实现类：</p>
<ul>
<li><p>ClassPathXmlApplicationContext</p>
<p>从类路径 ClassPath 中寻找指定的 XML 配置文件，找到并装载完成 ApplicationContext 的实例化工作。</p>
</li>
<li><p>FileSystemXmlApplicationContext</p>
<p>从指定的文件系统路径中寻找指定的 XML 配置文件，找到并装载完成 ApplicationContext 的实例化工作。</p>
</li>
</ul>
<p>FileSystemXmlApplicationContext 与 ClassPathXmlApplicationContext 的区别是：在读取 Spring  的配置文件时，FileSystemXmlApplicationContext  不再从类路径中读取配置文件，而是通过参数指定配置文件的位置，它可以获取类路径之外的资源，如 “F：/workspaces/applicationContext.xml”。</p>
<h3 id="BeanFactory和ApplicationContext的区别"><a href="#BeanFactory和ApplicationContext的区别" class="headerlink" title="BeanFactory和ApplicationContext的区别"></a>BeanFactory和ApplicationContext的区别</h3><h3 id="Spring-Bean的自动装配"><a href="#Spring-Bean的自动装配" class="headerlink" title="Spring Bean的自动装配"></a>Spring Bean的自动装配</h3><p>Spring可以通过向BeanFactory中注入的方式自动搞定Bean之间的依赖关系。自动装配可以设置在每个Bean上，也可以设置在特定的Bean上。</p>
<h3 id="自动装配的五种方式"><a href="#自动装配的五种方式" class="headerlink" title="自动装配的五种方式"></a>自动装配的五种方式</h3><ul>
<li>no：关闭自动装配</li>
<li>byName：通过参数名自动装配</li>
<li>byType：通过参数类型自动装配</li>
<li>constructor：通过设置构造器参数的方式来装配对象</li>
<li>autodetect：首次尝试使用constructor来自动装配，若无法完成，则采用byType方式进行装配。</li>
</ul>
<h3 id="Spring-Bean的装配流程"><a href="#Spring-Bean的装配流程" class="headerlink" title="Spring Bean的装配流程"></a>Spring Bean的装配流程</h3><p>Spring在启动是会从XML配置文件或注解中<strong>读取</strong>应用程序提供的Bean<strong>配置信息</strong></p>
<p>在Spring容器中<strong>生成</strong>一份相应的Bean配置<strong>注册表</strong>；</p>
<p>根据这张注册表<strong>实例化Bean</strong>，装配好Bean之间的依赖关系，为上层环境提供基础的运行环境。</p>
<p>其中Bean缓存池通过HashMap实现。</p>
<h3 id="Spring-Bean的作用域"><a href="#Spring-Bean的作用域" class="headerlink" title="Spring Bean的作用域"></a>Spring Bean的作用域</h3><p>Spring 为 Bean定义了五种作用域</p>
<ul>
<li>Singleton（单例）</li>
</ul>
<p>Singleton是单例模式，当实例类型为单例模式时，Spring IoC 容器中只会存在一个共享的Bean实例，无论有多少个Bean引用它，都始终指向同一个Bean对象。</p>
<p>Singleton作用域是 Spring 中的默认作用域，也可以通过配置将Bean定义为Sington模式。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alex.UserDaoImpl&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;sington&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Prototype（原型）</li>
</ul>
<p>Prototype是原型模式，每次通过Spring容器获取Prototype定义的Bean时，容器都将创建一个新的Bean实例，每个Bean实例都有自己的属性和状态，而Singleton全局只有一个对象。因此，队友状态的Bean经常使用Prototype作用域，而对无状态的Bean则使用Singleton作用域。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alex.UserService&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Request（请求级别）</li>
</ul>
<p>Request指在一次HTTP请求中容器会返回该Bean的同一个实例</p>
<ul>
<li>Session（会话级别）</li>
<li>Global Session（全局会话）</li>
</ul>
<h3 id="依赖注入（DI）"><a href="#依赖注入（DI）" class="headerlink" title="依赖注入（DI）"></a>依赖注入（DI）</h3><p>DI（Dependency  Injection，依赖注入）是指组件之间依赖关系由容器在运行期决定。形象的说，即由容器动态的将某个依赖关系注入到组件之中。</p>
<p>依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p>
<p><strong>谁依赖于谁：</strong>应用程序依赖于IoC容器。</p>
<p><strong>为什么需要依赖：</strong>应用程序需要IoC容器来提供对象需要的外部资源。</p>
<p><strong>谁注入谁：</strong>是IoC容器注入应用程序某个对象，应用程序依赖的对象。</p>
<p><strong>注入了什么：</strong>注入某个对象所需要的外部资源（包括对象、资源、常量数据）。</p>
<h3 id="Spring中的四种依赖注入"><a href="#Spring中的四种依赖注入" class="headerlink" title="Spring中的四种依赖注入"></a>Spring中的四种依赖注入</h3><p><strong>注入方式：</strong></p>
<ul>
<li>构造器注入</li>
<li>Set方式注入<br>依赖：bean对象的创建依赖于容器<br>注入：bean对象由容器注入</li>
<li>静态工厂注入</li>
<li>实例工厂注入</li>
</ul>
<p>Bean的自动装配</p>
<p>自动装配是Spring满足bean依赖的一种方式<br>Spring会在上下文中自动寻找，并自动给bean装配属性</p>
<ul>
<li>autowire</li>
<li>byname自动装配</li>
<li>byType</li>
</ul>
<p>@Autowired<br>@Qualifier(value=”cat”)</p>
<p>@Resource<br>先根据名字找，名字找不到根据类型找<br>@Resource(name=””)<br>后面可以指定name</p>
<h2 id="面向切面（AOP）"><a href="#面向切面（AOP）" class="headerlink" title="面向切面（AOP）"></a>面向切面（AOP）</h2><p>AOP（Aspect Orient Programming，面向切面编程）是一种编程思想，是面向对象编程（OOP）的一种补充。面向对象编程将程序抽象成各个层次的对象，而面向切面编程是将程序抽象成各个切面。</p>
<p>Spring AOP的主要目的是将非功能性需求从功能性需求中分离出来，达到解耦的目的。</p>
<p>AOP技术利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。</p>
<img src="E:\Document\学习笔记\图片\aop.png" alt="img" style="zoom:67%;" />

<p>所谓切面，相当于应用对象间的横切点，我们可以将其单独抽象为单独的模块。</p>
<p>静态 AOP 实现， AOP 框架在编译阶段对程序源代码进行修改，生成了静态的 AOP 代理类（生成的 *.class 文件已经被改掉了，需要使用特定的编译器），比如 AspectJ。</p>
<p>动态 AOP 实现， AOP 框架在运行阶段对动态生成代理对象（在内存中以 JDK 动态代理，或 CGlib 动态地生成 AOP 代理类），如 SpringAOP。</p>
<h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h3><p>Spring Aop 提供了 JDK 和 CGLib 两种方式来生成代理对象，具体生成代理的方式由 AopProxyFactory 根据AdvisedSupport对象的配置来决定。</p>
<p>Spring 默认的代理对象生成策略为：如果是目标类接口，则使用 JDK 动态代理技术，否则使用CGLib动态代理技术。</p>
<p><strong>Spring AOP就是基于动态代理的</strong>，如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong> ，这时候Spring AOP会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p>
<p><img src="5.Spring.assets/SpringAOPProcess.jpg" alt="SpringAOPProcess"></p>
<p>基于接口的动态代理：JDK的动态代理<br>基于类：cglib</p>
<h4 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h4><p>主要通过 java.lang.reflect 包中 Proxy 类和 InvocationHandler 接口来实现。 </p>
<p>InvocationHandler 是一个接口，不同的实现类定义不同的横切逻辑，并通过反射机制调用目标类的代码，动态地将横切逻辑和业务逻辑编制在一起。</p>
<p>Proxy类利用 InvocationHandler 动态创建一个符合某一接口的实例，生成目标类的代理对象。</p>
<h4 id="CGLib-动态代理"><a href="#CGLib-动态代理" class="headerlink" title="CGLib 动态代理"></a>CGLib 动态代理</h4><p>Code Generation Library，它是一个高性能管道代码生成类库，可以在运行期间扩展Java类和实现Java接口。</p>
<p>CGLib 包的底层通过字节码处理 ASM 来实现，通过转换字节码生成新的类。</p>
<p>CGLib 动态代理 和 JDK 动态代理的区别：JDK只能为接口创建代理实例，而对于没有通过接口定义业务方法的类，则只能通过 CGLib 创建动态来实现。</p>
<p>java字节码实现–javassist？？？</p>
<h3 id="AOP的五种通知类型"><a href="#AOP的五种通知类型" class="headerlink" title="AOP的五种通知类型"></a>AOP的五种通知类型</h3><ol>
<li><p>前置通知</p>
<p>在一个方法执行之前执行通知</p>
</li>
<li><p>后置通知</p>
<p>在一个方法执行之后执行通知</p>
</li>
<li><p>成功通知</p>
<p>在一个方法执行成功之后执行通知（只有在方法执行成功时才执行通知）</p>
</li>
<li><p>异常通知</p>
<p>当一个方法执行抛出异常退出时，才执行该通知</p>
</li>
<li><p>环绕通知</p>
<p>在拦截方法调用之前和之后，分别执行通知</p>
</li>
</ol>
<h3 id="AOP的代码实现"><a href="#AOP的代码实现" class="headerlink" title="AOP的代码实现"></a>AOP的代码实现</h3><p>通过<code>@Aspect</code>注解声明一个切面</p>
<p>通过<code>@PointCut</code>定义需要拦截的方法</p>
<p>然后通过<code>@Before</code>、<code>@AfterReturning</code>、<code>@Aroud</code>分别实现前置通知、后置通知和环绕通知要执行的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span> <span class="comment">//定义切面</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionDemo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PointCut(value=&quot;execution(* com.alex.core.service.*.*.*(..))&quot;)</span>	<span class="comment">//定义要拦截的方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">point</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before(value=&quot;point()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;transaction begin&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@AfterReturning(value=&quot;point()&quot;)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;transcation commit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Aroud(&quot;point()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aroud</span><span class="params">(ProceedingJoinPoin joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;transaction begin&quot;</span>);</span><br><span class="line">        joinPoint.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;transcation commit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Spring-MVC的原理"><a href="#Spring-MVC的原理" class="headerlink" title="Spring MVC的原理"></a>Spring MVC的原理</h2><p>MVC（Model View Controller，模型-视图-控制器）</p>
<p>该框架围绕DispatcherServlet设计</p>
<p>DispatcherServlet 会把请求分发给各个处理器，并支持可配置的处理器映射和视图渲染等功能。</p>
<p>工作流程如下：</p>
<ol>
<li><p><strong>客户端发起HTTP请求</strong></p>
<p>客户端将请求提交到 DispatcherServlet</p>
</li>
<li><p><strong>寻找处理器</strong></p>
<p>由 DispatcherServlet控制器查询一个或多个HandlerMapping，找到处理该请求的 Controller</p>
</li>
<li><p><strong>调用处理器</strong></p>
<p>DispatcherServlet 将请求提交到 Controller</p>
</li>
<li><p><strong>调用业务处理逻辑并返回结果</strong></p>
<p>Controller 调用 Service 中的业务处理逻辑后，将处理结果返回 ModelAndView。</p>
</li>
<li><p><strong>处理视图映射并返回模型</strong></p>
<p>DispatcherServlet 查询一个或多个 ViewResoler 视图解析器，找到 ModelAndView 指定的视图。</p>
</li>
<li><p><strong>HTTP响应</strong></p>
<p>视图负责将结果在客户端浏览器上渲染和展示。</p>
</li>
</ol>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务保证了用户操作的<strong>原子性</strong>（Atmoicity）、<strong>一致性</strong>（Consistency）、<strong>隔离性</strong>（Isolation）和<strong>持久性</strong>（Durability）。</p>
<p>事务分<strong>本地事务</strong>和<strong>分布式事务</strong>两种。</p>
<h3 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h3><p>本地事务基于数据库资源实现，书屋串行地在JDBC连接上执行，本地事务将事务处理局限在当前事务资源内。</p>
<p>其特点是使用灵活但无法支持多数据源事务操作。</p>
<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>分布式事务（Distributed Transcation）提供了跨数据库的分布式事务操作的数据一致性</p>
<p>跨数据库的一致性包含同一类型数据库的多个数据库实例服务的一致性（例如多个MySQL的事务一致性）和多个不同类型数据库的数据一致性（例如MySQL和Oracle之间的事务一致性）</p>
<p>Java事务编程接口（Java Transcation API，JTA）和 Java事务服务（Java Transaction Service，JTS）为J2EE平台提供了分布式事务服务。</p>
<p>分布式事务包括一个事务管理器（Trabscation Manager）和一个或多个支持XA协议的资源管理器。</p>
<p>事务管理器负责所有事务参与单元的协调域控制</p>
<p>资源管理器负责不同的数据库具体的事务执行操作。</p>
<h3 id="两段提交协议"><a href="#两段提交协议" class="headerlink" title="两段提交协议"></a>两段提交协议</h3><h2 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h2><p><strong>什么是循环依赖？</strong></p>
<p>循环依赖其实就是循环引用，也就是两个或则两个以上的bean互相持有对方，最终形成闭环。比如A依赖于B，B依赖于C，C又依赖于A。</p>
<p><strong>怎么检测循环依赖？</strong></p>
<p>Bean在创建的时候可以给该Bean打标，如果递归调用回来发现正在创建中的话，即说明了循环依赖了。</p>
<p><strong>Spring怎么解决循环依赖？</strong></p>
<p>Spring为了解决单例的循环依赖问题，使用了<strong>三级缓存</strong></p>
<p>在实例化A时调用doGetBean，发现A依赖的B的实例，此时调用doGetBean去实例B，实例化的B的时候发现又依赖A，如果不解决这个循环依赖的话此时的doGetBean将会无限循环下去，导致内存溢出，程序奔溃。spring引用了一个早期对象，并且把这个”早期引用”并将其注入到容器中，让B先完成实例化，此时A就获取B的引用，完成实例化。</p>
<p>Spring的循环依赖的理论依据其实是基于Java的引用传递，当我们获取到对象的引用时，对象的field或则属性是可以延后设置的(但是构造器必须是在获取引用之前)。</p>
<p><strong>Spring 无法解决的循环依赖问题</strong></p>
<p>Spring不能解决“A的构造方法中依赖了B的实例对象，同时B的构造方法中依赖了A的实例对象”这类问题。因为加入singletonFactories三级缓存的前提是执行了构造器，所以构造器的循环依赖没法解决。</p>
<h2 id="Spring配置"><a href="#Spring配置" class="headerlink" title="Spring配置"></a>Spring配置</h2><p><strong>别名</strong> <strong>alias</strong><br><strong>bean的配置</strong><br>id=”userT”  bean的唯一标识符相当于对象名<br>class: bean对象所对应的全限定名: 包名+类名<br>name: 也是别名，而且name可以同时取多个别名，可以通过空格或逗号分割</p>
<p><strong>import</strong><br>一般用于团队开发，将多个xml配置文件导入合并为一个配置文件，使用时直接使用总的配置就可以了<br><code>&lt;import resource=&quot;&quot;&gt;</code></p>
<p><strong>使用Java的方式配置Spring</strong><br>JavaConfig是Spring的一个子项目</p>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="spring中-Autowire和-Resource的区别"><a href="#spring中-Autowire和-Resource的区别" class="headerlink" title="spring中@Autowire和@Resource的区别"></a>spring中@Autowire和@Resource的区别</h3><h3 id="RequestBody和-ResponseBody的区别"><a href="#RequestBody和-ResponseBody的区别" class="headerlink" title="@RequestBody和@ResponseBody的区别"></a>@RequestBody和@ResponseBody的区别</h3><h3 id="Component-Service和-Repository"><a href="#Component-Service和-Repository" class="headerlink" title="@Component,@Service和@ Repository"></a>@Component,@Service和@ Repository</h3><h3 id="transactional"><a href="#transactional" class="headerlink" title="@transactional"></a>@transactional</h3><h3 id="mvc里的HandlerMapping和Handler"><a href="#mvc里的HandlerMapping和Handler" class="headerlink" title="mvc里的HandlerMapping和Handler"></a>mvc里的HandlerMapping和Handler</h3><h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="什么是-Spring-Boot"><a href="#什么是-Spring-Boot" class="headerlink" title="什么是 Spring Boot"></a>什么是 Spring Boot</h2><p>Spring Boot的设计目的是用来简化Spring应用烦琐的搭建以及开发过程。通过它只需要使用极少的配置，就可以得到一个可正常运行的应用程序。</p>
<p>Spring Boot其实并不能称之为新框架，它只是默认配置了很多常用框架（这被称为 “ 起步依赖 ” ），Spring Boot整合了大部分常用的框架（包括他们的使用方式以及常用配置）。</p>
<p>Spring Boot 的诞生给企业快速开发微小的项目提供了可能。</p>
<h2 id="Spring-Boot的优势"><a href="#Spring-Boot的优势" class="headerlink" title="Spring Boot的优势"></a>Spring Boot的优势</h2><ol>
<li>从搭建的角度看，Spring Boot可以帮助开发者快速搭建企业级应用。</li>
<li>从整合第三方框架的角度看，传统的Spring应用如果需要整合第三方框架，需要加入大量的XML配置文件，并配置很多晦涩难懂的参数；而对于Spring Boot而言，只需要加入Spring Boot内置的针对第三方的 “<strong>起步依赖</strong>“，即内置的Jar包即可，不再需要编写大量的样板代码、注释和进行繁琐的XML配置</li>
<li>从项目运行的角度看，Spring Boot<strong>内置了Servlet容器</strong>（如Tomcat），其搭建的项目可以直接打成Jar包，在安装由Java运行环境的服务器上直接运行，省去了额外安装以及配置Servlet容器的步骤，可以说非常方便。Spring Boot还能对运行中的应用进行状态的监控。</li>
<li>从开发和部署的角度看，使用Spring Boot搭建项目的<strong>代码和配置文件</strong>更少了，不需要再对第三方矿建的配置而烦恼了。项目整体来看也跟家精简，扩展性编点更强了，可更大地节约开发和维护成本。</li>
<li>由于SpringBoot是Spring家族的一员，所以对于Spring Boot应用而言，其与Spring家族的其他成员如Spring ORM、Spring JDBC、Spring Data、Spring Security等的集成非常方便、容易。</li>
</ol>
<p>简单来说，Spring Boot提供以下四个好处：</p>
<ul>
<li>使代码更加简单。</li>
<li>简化了配置。</li>
<li>使部署更加便捷。</li>
<li>使应用的监控变得更加简单和方便。</li>
</ul>
<h2 id="Spring-Boot的六个特性"><a href="#Spring-Boot的六个特性" class="headerlink" title="Spring Boot的六个特性"></a>Spring Boot的六个特性</h2><ul>
<li>遵循<strong>习惯优于配置</strong>理念，即开发项目时，只需要进行很少的配置，大部分情况下使用默认配置即可。</li>
<li>可以帮助开发者快速地搭建应用，并自动整合主流框架和大部分第三方框架，即<strong>自动装配</strong>。</li>
<li>对于应用可以不需要使用XML配置，而只需要采用<strong>自动配置</strong>或采用<strong>Java Config配置</strong>相关组件。</li>
<li>采用<strong>内置的Servlet容器</strong>，并采用简单的命令直接执行项目，可以不需要借助外置的容器便可运行。</li>
<li>整合主流框架或大部分的第三方框架时，只需要直接引入Spring Boot内置的Start Jar即可，这个特性称为 “<strong>起步依赖</strong>”，可以很方便地进行包管理。</li>
<li>Spring Boot <strong>内置了监控组件Actuator</strong>，只需要引入相应的起步依赖，就可以基于HTTP、SSH、Telnet等方式对运行中的应用进行监控。</li>
</ul>
<h2 id="为什么可以快速开发"><a href="#为什么可以快速开发" class="headerlink" title="为什么可以快速开发"></a>为什么可以快速开发</h2><h2 id="启动器里集成了哪些"><a href="#启动器里集成了哪些" class="headerlink" title="启动器里集成了哪些"></a>启动器里集成了哪些</h2><h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><p>Spring Framework最核心的功能是IOC和AOP， IoC容器的主要功能是可以管理对象的生命周期。也就是bean的管理。我们把Bean对象托管到Spring Ioc容器的这个过程称为装配。</p>
<p><img src="5.Spring.assets/2020070215205383.png" alt="在这里插入图片描述"></p>
<p> 在Spring boot框架中，我们可以不必配置xml文件，就能完成Bean注入IOC的动作。这在之前的Spring是通过xml配置来说明要装配的组件，Spring boot为了简化开发人员的配置工作，遵循 “约定大于配置，配置大于编码” 原则，</p>
<p>通过约定来实现IOC的注入，通过默认配置来代替常规的配置，从而简化了开发人员的配置和开发过程，提升研发效率。</p>
<p> 整体流程是@EnableAutoConfiguration中的实现类扫描 “classpath下即Pom依赖” 中所有包含/META-INF/spring.factories的包，并根据其xxxAutoConfiguration和/META-INF/spring-autoconfigure-metadata.properties中的条件判断来决定是否进行自动装配。</p>
<h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h3><h4 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h4><h4 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h4><p>一旦加上此注解，那么将会开启自动装配功能，简单点讲，Spring会试图在你的classpath下找到所有配置的Bean然后进行装配。当然装配Bean时，会根据若干个(Conditional)定制规则来进行初始化。</p>
<h4 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h4><p>此处@ComponentScan由于没有指定扫描包，因此它默认扫描的是与该类同级的类或者同级包下的所有类</p>
<h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><h3 id="SpringBootApplication-1"><a href="#SpringBootApplication-1" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h3><p>定义在main方法入口类处，用于启动 Sping Boot 应用项目。</p>
<h3 id="RequestMapping。。。"><a href="#RequestMapping。。。" class="headerlink" title="@RequestMapping。。。"></a>@RequestMapping。。。</h3><p>用来映射web请求(访问路径和参数)、处理类和方法，可以注解在类或方法上。</p>
<p>注解在方法上的路径会继承注解在类上的路径。</p>
<p>produces属性: 定制返回的response的媒体类型和字符集，或需返回值是json对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/demo/copper&quot;,produces=&quot;application/json;charset=UTF-8&quot;,method = RequestMethod.POST)</span></span><br></pre></td></tr></table></figure>

<h3 id="PostMapping。。。"><a href="#PostMapping。。。" class="headerlink" title="@PostMapping。。。"></a>@PostMapping。。。</h3><ul>
<li><p>类上</p>
</li>
<li><p>函数上</p>
</li>
</ul>
<h3 id="DeleteMapping。。。"><a href="#DeleteMapping。。。" class="headerlink" title="@DeleteMapping。。。"></a>@DeleteMapping。。。</h3><h3 id="GetMapping。。。"><a href="#GetMapping。。。" class="headerlink" title="@GetMapping。。。"></a>@GetMapping。。。</h3><h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h3><p>获取request请求的参数值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;CopperVO&gt; <span class="title">getOpList</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="meta">@RequestParam(value = &quot;pageIndex&quot;, required = false)</span> Integer pageIndex,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="meta">@RequestParam(value = &quot;pageSize&quot;, required = false)</span> Integer pageSize)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Param-（dao层）。。。"><a href="#Param-（dao层）。。。" class="headerlink" title="@Param （dao层）。。。"></a>@Param （dao层）。。。</h3><h3 id="RequestBody。。。"><a href="#RequestBody。。。" class="headerlink" title="@RequestBody。。。"></a>@RequestBody。。。</h3><h3 id="ResponseBody。。。"><a href="#ResponseBody。。。" class="headerlink" title="@ResponseBody。。。"></a>@ResponseBody。。。</h3><p>支持将返回值放在response体内，而不是返回一个页面。比如Ajax接口，可以用此注解返回数据而不是页面。此注解可以放置在返回值前或方法前。</p>
<h3 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(name=&quot;bean的名字&quot;,initMethod=&quot;初始化时调用方法名字&quot;,destroyMethod=&quot;close&quot;)</span></span><br></pre></td></tr></table></figure>

<p>定义在方法上，在容器内初始化一个bean实例类。</p>
<h3 id="Service"><a href="#Service" class="headerlink" title="@Service"></a>@Service</h3><p>用于标注业务层组件</p>
<h3 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h3><p>用于标注控制层组件(如struts中的action)</p>
<h3 id="Repository"><a href="#Repository" class="headerlink" title="@Repository"></a>@Repository</h3><p>用于标注数据访问组件，即DAO组件</p>
<h3 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h3><p>泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</p>
<h3 id="PostConstruct"><a href="#PostConstruct" class="headerlink" title="@PostConstruct"></a>@PostConstruct</h3><p>spring容器初始化时，要执行该方法</p>
<h3 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h3><p>用来获得请求url中的动态参数</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="Select-Insert。。。"><a href="#Select-Insert。。。" class="headerlink" title="@Select @Insert。。。"></a>@Select @Insert。。。</h3><h3 id="DateTimeFormat。。。"><a href="#DateTimeFormat。。。" class="headerlink" title="@DateTimeFormat。。。"></a>@DateTimeFormat。。。</h3><p>java.sql.TimeStamp</p>
<h3 id="Autowire。。。"><a href="#Autowire。。。" class="headerlink" title="@Autowire。。。"></a>@Autowire。。。</h3><h3 id="CrossOrigin。。。"><a href="#CrossOrigin。。。" class="headerlink" title="@CrossOrigin。。。"></a>@CrossOrigin。。。</h3><h3 id="Slf4j。。。"><a href="#Slf4j。。。" class="headerlink" title="@Slf4j。。。"></a>@Slf4j。。。</h3><h3 id="ServerEndpoint。。。"><a href="#ServerEndpoint。。。" class="headerlink" title="@ServerEndpoint。。。"></a>@ServerEndpoint。。。</h3><h3 id="Configuration。。。"><a href="#Configuration。。。" class="headerlink" title="@Configuration。。。"></a>@Configuration。。。</h3><h3 id="Value。。。"><a href="#Value。。。" class="headerlink" title="@Value。。。"></a>@Value。。。</h3><h1 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h1><h1 id="Shiro"><a href="#Shiro" class="headerlink" title="Shiro"></a>Shiro</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h2><p>Apache Shiro 是一个强大易用的 Java 安全框架，提供了认证、授权、加密和会话管理等功能，对于任何一个应用程序，Shiro 都可以提供全面的安全管理服务。</p>
<h2 id="与Spring-Security的区别"><a href="#与Spring-Security的区别" class="headerlink" title="与Spring Security的区别"></a>与Spring Security的区别</h2><p>没有 Spring Security 做的功能强大，但Shiro小而简单。</p>
<h2 id="shiro-主要功能"><a href="#shiro-主要功能" class="headerlink" title="shiro 主要功能"></a><strong>shiro 主要功能</strong></h2><p><img src=".%5C%E5%9B%BE%E7%89%87%5CSpring%5Cshiro-1.png" alt="img"></p>
<ul>
<li><strong>Authentication</strong>：身份认证/登录，验证用户是不是拥有相应的身份；</li>
<li><strong>Authorization</strong>：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限；</li>
<li><strong>Session Manager：</strong>会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通JavaSE环境的，也可以是如Web环境的；</li>
<li><strong>Cryptography</strong>：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储；</li>
<li><strong>Web Support</strong>：Web支持，可以非常容易的集成到Web环境</li>
<li><strong>Caching</strong>：缓存，比如用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可以提高效率；</li>
<li><strong>Concurrency</strong>：Shiro支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；</li>
<li><strong>Testing</strong>：提供测试支持；</li>
<li><strong>Run As</strong>：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；</li>
<li><strong>Remember Me</strong>：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。</li>
</ul>
<p><strong>Shiro的三个核心组件</strong></p>
<p><img src="https://atts.w3cschool.cn/attachments/image/wk/shiro/2.png" alt="img"></p>
<ul>
<li><p><strong>Subject</strong>，主体，即 ”当前操作用户“。Subject代表了当前用户的安全操作（需要被认证的对象）。应用代码直接交互的对象是 Subject，也就是说 Shiro 的对外 API 核心就是 Subject。</p>
<p>这个用户不一定是一个具体的人，与当前应用交互的任何东西都是  Subject，如网络爬虫，机器人等；即一个抽象概念；所有 Subject 都绑定到 SecurityManager，与 Subject  的所有交互都会委托给 SecurityManager；可以把 Subject 认为是一个门面；SecurityManager 才是实际的执行者；</p>
</li>
<li><p><strong>SecurityManager</strong></p>
<ul>
<li>它是Shiro框架的核心，管理所有用户的安全操作，并提供安全管理的各种服务。</li>
<li>管理着所有 Subject；可以看出它是 Shiro  的核心，它负责与后边介绍的其他组件进行交互，如果学习过 SpringMVC，你可以把它看成 DispatcherServlet 前端控制器；</li>
</ul>
</li>
<li><p><strong>Realm</strong>： </p>
<ul>
<li>域，Shiro 从从 Realm 获取安全数据（如用户、角色、权限），就是说 SecurityManager 要验证用户身份，那么它需要从  Realm 获取相应的用户进行比较以确定用户身份是否合法</li>
<li>也需要从 Realm 得到用户相应的角色 / 权限进行验证用户是否能进行操作</li>
<li>可以把  Realm 看成 DataSource，即安全数据源。</li>
<li>Realm充当了Shiro与应用安全数据间的“桥梁”或者“连接器”。也就是说，当对用户执行认证（登录）和授权（访问控制）验证时，Shiro会从应用配置的Realm中查找用户及其权限信息。</li>
</ul>
</li>
</ul>
<p>相关权限过滤器</p>
<ul>
<li>anon：匿名过滤器，未登陆也可以访问</li>
<li>authc：认证过滤器， 登陆后访问</li>
<li>perms：需要xx权限，才能访问</li>
<li>user：需要xx用户，才能访问</li>
<li>port：指定端口才能访问</li>
<li>ssl：必须使用https协议才能访问</li>
<li>logout：登出功能</li>
<li>rest：根据指定HTTP请求访问才能访问</li>
<li>get方式提交 或者 post方式提交才能访问</li>
</ul>
<p><strong>shiro 架构</strong></p>
<p>不管是任何请求都会经过　SecurityManager 拦截并进行相应的处理，shiro 几乎所有的功能都是由 SecurityManager 来管理。</p>
<h2 id="shiro登陆认证过程原理"><a href="#shiro登陆认证过程原理" class="headerlink" title="shiro登陆认证过程原理"></a>shiro登陆认证过程原理</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/k393393/article/details/112550976">https://blog.csdn.net/k393393/article/details/112550976</a></p>
<p>登陆请求及用户名和密码数据传到后端的 controller里后，</p>
<p>可以先获得一个subject实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Subject subject = SecurityUtils.getSubject();</span><br></pre></td></tr></table></figure>

<p>将用户名和密码信息封装成一个token</p>
<p>调用subject的login方法，该方法为Subject接口里的一个抽象方法。</p>
<p>SecurityManager会拦截者个方法的请求，并做相应的处理。</p>
<p>可以通过继承 <code>AuthorizingRealm</code> 类并重写其中的认证方法 <code>doGetAuthenticationInfo</code> 来实现登陆认证过程。</p>
<p>Subject是主体，是对外API。</p>
<p>SecurityManager是Shiro框架的核心，管理所有用户的安全操作，并提供安全管理的各种服务。</p>
<p>Realm负责从数据库中获取数据，而Shiro 从从 Realm 获取安全数据（如用户、角色、权限），就是说 SecurityManager 要验证用户身份，那么它需要从  Realm 获取相应的用户进行比较以确定用户身份是否合法。</p>
<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="防SQL注入"><a href="#防SQL注入" class="headerlink" title="防SQL注入"></a>防SQL注入</h2><p>SQL注入攻击，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。</p>
<p>具体来说，它是利用现有应用程序，将恶意的SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入特殊的恶意的SQL语句从而得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句。</p>
<p>若是在编写代码的时候，没有对用户输入数据的合法性进行判断，应用程序可能存在安全隐患。</p>
<p>传入SQL语句可控参数分为两类：</p>
<ul>
<li>数字类型，参数不用被引号括起来，如?id=1；</li>
<li>其他类型，参数要被引号扩起来，如?name=”phone”。除此之外，用户可以构造SQL语句万能密码’or 1=1#；username’#，在已知用户名的情况下，可绕过输入密码。</li>
</ul>
<p>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。</p>
<p>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</p>
<p>MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 Pojos（Plain Ordinary Java Object，普通的 Java对象)映射成数据库中的记录。</p>
<p>Mybatis启用了<strong>预编译</strong>功能，在sql语句执行前，会先将上面的sql发送给数据库进行编译，执行时，直接使用编译好的sql，替换占位符“？“就可以了。因为sql注入只能对编译过程起作用，所以这样的方式就很好地避免了sql注入的问题，其中主要是#和$的区别。</p>
<ul>
<li><p><strong># 将sql进行预编译</strong>where id = ?，然后底层再使用PreparedStatement的set方法进行参数设置。</p>
</li>
<li><p>$ 将传入的数据直接将参数拼接在sql中，比如 “where id = 123”。</p>
</li>
</ul>
<p>因此，#与$相比，#可以很大程度的防止sql注入，因为对sql做了预编译处理，因此在使用中<strong>一般使用#{}方式</strong>。</p>
<h2 id="MyBatis的缓存"><a href="#MyBatis的缓存" class="headerlink" title="MyBatis的缓存"></a>MyBatis的缓存</h2><p>MyBatis 的缓存分为一级缓存和二级缓存。默认情况下，以及缓存是开启的，而且不能被关闭。</p>
<p>一级缓存：指SqlSession级别的缓存</p>
<p>二级缓存：指跨SqlSession级别的缓存，即Mapper级别的缓存</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="GET和Post的区别"><a href="#GET和Post的区别" class="headerlink" title="GET和Post的区别"></a>GET和Post的区别</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/25/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-id="ckp3gdqgy0000poupexy426ob" data-title="Spring学习笔记" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-MySQL学习笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/25/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2021-05-25T03:01:29.000Z" itemprop="datePublished">2021-05-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/25/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">MySQL学习笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/williamjie/p/11187470.html">https://www.cnblogs.com/williamjie/p/11187470.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/madongyu1259892936/article/details/98977113">https://blog.csdn.net/madongyu1259892936/article/details/98977113</a></p>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="数据库与实例"><a href="#数据库与实例" class="headerlink" title="数据库与实例"></a>数据库与实例</h2><p><strong>数据库</strong>（database）：物理操作系统文件或其他形式文件类型的集合。</p>
<p><strong>实例</strong>（instance）：MySQL数据库由后台线程以及一个共享内存区组成。数据库实例才是真正用于操作数据库文件的。</p>
<p>从概念上将，</p>
<p>数据库是<strong>文件的集合</strong>，是以找某种数据模型组织起来并存放于二级存储器中的数据集合；</p>
<p>数据库实例是<strong>程序</strong>，是位于用户与操作系统之间的一层<strong>数据管理软件</strong>， 用户对数据的任何操作，包括数据库定义、数据查询、数据维护、数据库运行控制等都是在数据库实例下进行的，应用程序只有通过数据库实例才能和数据库打交道。</p>
<p>在MySQL数据库中，实例与数据库的关系通常是一一对应的，即一个实例对应一个数据库。但是，在集群情况下可能存在一个数据库被多个数据实例使用的情况。</p>
<p>MySQL被设计为一个单进程多线程架构的数据库，MySQL数据库实例在系统上的表现就是一个进程。</p>
<h2 id="实例的启动"><a href="#实例的启动" class="headerlink" title="实例的启动"></a>实例的启动</h2><p>当启动实例时，MySQL数据库会去读取配置文件，根据配置文件的参数来启动数据库实例。</p>
<p>如果没有参数，在启动实例时，MySQL会按照编译时的默认参数设置启动实例。</p>
<h2 id="MySQL的组成"><a href="#MySQL的组成" class="headerlink" title="MySQL的组成"></a>MySQL的组成</h2><ul>
<li>连接池组件</li>
<li>管理服务和工具组件</li>
<li>SQL接口组件</li>
<li>查询分析器组件</li>
<li>优化器组件</li>
<li>缓冲（cache）组件</li>
<li><strong>插件式存储引擎</strong></li>
<li>物理组件</li>
</ul>
<h2 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h2><p>MySQL数据库区别于其他数据库的最重要的一个特点就是其插件式的表存储引擎。</p>
<p><strong>存储引擎是基于表的，而不是数据库</strong></p>
<p>存储引擎的好处：每个存储引擎都有各自的特点，能够根据具体的应用建立不同存储引擎表。</p>
<ul>
<li><strong>InnoDB存储引擎</strong>，MySQL5.5.8开始作为默认存储引擎。</li>
<li><strong>MyISAM存储引擎</strong>，MySQL5.5.8之前的默认存储引擎（Windows版本除外）</li>
<li><strong>NDB存储引擎</strong></li>
<li><strong>Memory存储引擎</strong></li>
<li><strong>Archive存储引擎</strong></li>
<li><strong>Federated存储引擎</strong></li>
<li><strong>Maria存储引擎</strong></li>
</ul>
<h2 id="连接-MySQL"><a href="#连接-MySQL" class="headerlink" title="连接 MySQL"></a>连接 MySQL</h2><p>连接 MySQL 操作时一个连接进程和MySQL数据库实例进行通信。</p>
<p>本质上是进程通信。</p>
<p>常用的进程通信方式有<strong>管道</strong>、<strong>命名管道</strong>、<strong>TCP/IP套接字</strong>、<strong>UNIX套接字</strong></p>
<ul>
<li><p>TCP/IP</p>
<p>是在任何平台下都提供的连接方式，使用最多。</p>
<p>这种连接方式在TCP/IP连接上建立一个基于网络的连接请求，一般情况下客户端（cline）在一台服务器上，而MySQL实例（server）在另一台服务器上，两台服务器通过过一个TCP/IP连接。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h192.168.0.101 -u wang -p</span><br></pre></td></tr></table></figure>

<p>在通过TCP/IP连接到MySQL实例时，MySQL数据库会查一张权限视图，用来判断发起请求的客户端IP是否允许连接到MySQL实例。</p>
<p>该视图在MySQL架构下，表名为user。 </p>
</li>
<li><p>命名管道和共享内存</p>
<p>在MySQL数据库中需在配置文件中启用–enable-named-pipe选项。</p>
<p>MySQL4.1后，MySQL还提供了共享内存的连接方式，是通过在配置文件中添加–shared-memory实现的。</p>
<p>如果想使用共享内存的方式，在连接时，客户端必须使用–protocal=memory选项。</p>
</li>
<li><p>UNIX域套接字</p>
<p>Linux和Unix环境下可以使用UNIX域套接字。</p>
<p>只能在MySQL数据库和客户端在同一台服务器上时使用。</p>
<p>用户可以在配置文件中指定套接字文件的路径，如–socket=/tmp/mysql.sock。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -udavid -S /tmp/mysqql.sock</span><br></pre></td></tr></table></figure></li>
</ul>
<p>如果几个配置文件中都有同一个参数，MySQL数据库会以读取到的最后一个配置文件中的参数为准</p>
<h2 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h2><ul>
<li><p><strong>第一范式：</strong>数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。（保持数据的原子性）</p>
<p><strong>即表中的字段不可再分。</strong></p>
</li>
<li><p><strong>第二范式：</strong>在满足第一范式的基础上，实体的每个非主键属性完全函数依赖于主键属性（消除部分依赖）</p>
</li>
<li><p><strong>第三范式：</strong>在满足第二范式的基础上，在实体中不存在非主键属性传递函数依赖于主键属性。（表中非主键字段不存在对主键的传递依赖）</p>
</li>
</ul>
<p>部分依赖：当主键由两个或两个以上字段构成，而表中的某些信息通过主键的一个字段就能唯一确定，我们称这样的依赖关系为部分依赖</p>
<p>不符合第二范式会带来哪些问题呢？</p>
<p>1、数据信息冗余，可见上表</p>
<p>2、增删改会出现问题，比如有一门《微机原理》没有人选，那么由于缺少学号（主键之一）那么这门课就不能出现在表里。</p>
<h2 id="myisam、innodb区别"><a href="#myisam、innodb区别" class="headerlink" title="myisam、innodb区别"></a>myisam、innodb区别</h2><ol>
<li><p>InnoDB支持<strong>事务</strong>，MyISAM不支持。对于InnoDB，每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务。 </p>
</li>
<li><p>InnoDB支持<strong>外键</strong>，而MyISAM不支持。一个包含外键的InnoDB表转为MYISAM会失败。</p>
</li>
<li><p>InnoDB是<strong>聚集索引</strong>，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。</p>
</li>
</ol>
<p>  MyISAM是<strong>非聚集索引</strong>，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的<strong>指针</strong>。主键索引和辅助索引是独立的。</p>
<p>  也就是说：InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。</p>
<ol start="4">
<li><p><strong>InnoDB不保存表的具体行数</strong>，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">为什么InnoDB没有了这个变量呢？</span><br><span class="line"></span><br><span class="line">因为InnoDB的事务特性，在同一时刻表中的行数对于不同的事务而言是不一样的，因此count统计会计算对于当前事务而言可以统计到的行数，而不是将总行数储存起来方便快速查询。InnoDB会尝试遍历一个尽可能小的索引除非优化器提示使用别的索引。如果二级索引不存在，InnoDB还会尝试去遍历其他聚簇索引。</span><br><span class="line">如果索引并没有完全处于InnoDB维护的缓冲区（Buffer Pool）中，count操作会比较费时。可以建立一个记录总行数的表并让你的程序在INSERT/DELETE时更新对应的数据。和上面提到的问题一样，如果此时存在多个事务的话这种方案也不太好用。如果得到大致的行数值已经足够满足需求可以尝试SHOW TABLE STATUS</span><br></pre></td></tr></table></figure></li>
<li><p><strong>MyISAM表格可以被压缩后进行查询操作</strong>。</p>
</li>
<li><p><strong>InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁</strong>。</p>
<p>InnoDB的行锁是实现在索引上的，而不是锁在物理行记录上。潜台词是，如果访问没有命中索引，也无法使用行锁，将要退化为表锁。</p>
</li>
<li><p><strong>InnoDB表必须有唯一索引（如主键）（用户没有指定的话会自己找/生产一个隐藏列Row_id来充当默认主键），而Myisam可以没有</strong></p>
</li>
</ol>
<p><strong>如何选择：</strong></p>
<ol>
<li>是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；</li>
<li>如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读也有写，请使用InnoDB。</li>
<li>系统奔溃后，MyISAM恢复起来更困难，能否接受；</li>
<li>MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。</li>
</ol>
<p><strong>InnoDB为什么推荐使用自增ID作为主键？</strong></p>
<p>  <strong>答：自增ID可以保证每次插入时B+索引是从右边扩展的，可以避免B+树和频繁合并和分裂（对比使用UUID）。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。</strong></p>
<h2 id="innodb引擎的关键特性"><a href="#innodb引擎的关键特性" class="headerlink" title="innodb引擎的关键特性"></a>innodb引擎的关键特性</h2><p>插入缓冲（insert buffer)</p>
<p>两次写(double write)</p>
<p>自适应哈希索引(ahi)</p>
<p>异步IO</p>
<p>刷新邻接页</p>
<p>预读(read ahead)</p>
<h2 id="页"><a href="#页" class="headerlink" title="页"></a>页</h2><p>Mysql的基本存储结构是页（记录都存在页里边）</p>
<p>各个数据页可以组成一个双向链表，而每个数据页中的记录又可以组成一个单向链表</p>
<p>每个数据页都会为存储在它里边的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录</p>
<p>以其他列(非主键)作为搜索条件：只能从最小记录开始依次遍历单链表中的每条记录。</p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h2><p>“索引”是为了能够更快地查询数据。</p>
<p>如果查询语句使用到了索引，会先去索引里面查询，取得数据所在行的物理地址，进而访问数据。 myisam</p>
<h2 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h2><p><strong>优势：</strong></p>
<ul>
<li>快速检索，减少I/O次数，加快检索速度；</li>
<li>根据索引分组和排序，可以加快分组和排序；</li>
</ul>
<p><strong>劣势：</strong></p>
<ul>
<li>索引本身也是表，因此会占用存储空间。</li>
<li>索引的维护和创建需要时间成本，这个成本随着数据量增大而增大；</li>
<li>构建索引会降低数据表的修改操作（删除，添加，修改）的效率，因为在修改数据表的同时还需要修改索引表。</li>
</ul>
<h2 id="索引的创建"><a href="#索引的创建" class="headerlink" title="索引的创建"></a>索引的创建</h2><p><img src="E:\Document\学习笔记\图片\数据库\索引创建方式.png" alt="f1957c4fde62f149224b19889f82ba48.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name</span><br><span class="line">[col_name data type]</span><br><span class="line">[unique|fulltext]</span><br><span class="line">[index|key]</span><br><span class="line">[index_name]</span><br><span class="line">(col_name[length])</span><br><span class="line">[asc|desc]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>unique|fulltext</code>为可选参数，分别表示唯一索引、全文索引 </li>
<li><code>index</code>和<code>key</code>为同义词，两者作用相同，用来指定创建索引 </li>
<li><code>col_name</code>为需要创建索引的字段列，该列必须从数据表中该定义的多个列中选择 </li>
<li><code>index_name</code>指定索引的名称，为可选参数，如果不指定，默认<code>col_name</code>为索引值 </li>
<li><code>length</code>为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度 </li>
<li><code>asc</code>或<code>desc</code>指定升序或降序的索引值存储</li>
</ul>
<h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/7897.html">http://c.biancheng.net/view/7897.html</a></p>
<table>
<thead>
<tr>
<th>按照算法分类</th>
<th>B tree索引、hash索引、R tree索引、Full text 索引</th>
</tr>
</thead>
<tbody><tr>
<td>按照字段约束分类</td>
<td>主键索引、唯一索引、普通索引、简单索引、组合索引</td>
</tr>
<tr>
<td>按照索引字段是否排序分类</td>
<td>聚簇索引、非聚簇索引</td>
</tr>
<tr>
<td>聚簇索引按照索引量分类</td>
<td>稠密索引、稀疏索引</td>
</tr>
</tbody></table>
<p>数据库中按照数据结构来分，常见的索引有B-tree索引和Hash索引，不同的存储引擎对于索引又不相同。。。</p>
<h2 id="根据字段约束分类"><a href="#根据字段约束分类" class="headerlink" title="根据字段约束分类"></a>根据字段约束分类</h2><p>MySQL目前主要有以下五种索引类型： </p>
<p>普通索引、唯一索引、主键索引、组合索引、全文索引</p>
<h3 id="普通索引（简单索引）"><a href="#普通索引（简单索引）" class="headerlink" title="普通索引（简单索引）"></a>普通索引（简单索引）</h3><ul>
<li>普通索引是最基本的索引，它没有任何限制，仅加速查询。</li>
</ul>
<p>普通索引可以是聚簇索引，也可以是非聚簇索引</p>
<h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><ul>
<li>索引列的值必须唯一，但允许有空值。</li>
<li>如果是组合索引，则列值的组合必须唯一。</li>
</ul>
<h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><ul>
<li><p>主键索引是一种特殊的唯一索引。</p>
</li>
<li><p>一个表只能有一个主键，不允许有空值。</p>
</li>
<li><p>一般是在建表的时候同时创建主键索引。</p>
</li>
</ul>
<h3 id="组合索引（联合索引）"><a href="#组合索引（联合索引）" class="headerlink" title="组合索引（联合索引）"></a>组合索引（联合索引）</h3><p>又称为多列索引，多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</p>
<p>MySQL在根据索引查询时，会遵循 “ 最左匹配 ” 原则，即先根据col1的条件查，再根据col2的条件查，然后再根据col3的条件去查。</p>
<ul>
<li><p>组合索引指多个字段上创建的索引</p>
</li>
<li><p>只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。</p>
</li>
<li><p>使用组合索引时遵循最左前缀集合</p>
</li>
</ul>
<h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><ul>
<li>对文本的内容进行分词，进行搜索</li>
</ul>
<ul>
<li>主要用来查找文本中的关键字，而不是直接与索引中的值相比较。</li>
<li><code>fulltext</code>索引配合<code>match against</code>操作使用，而不是一般的where语句加like。</li>
</ul>
<h2 id="根据数据结构分类"><a href="#根据数据结构分类" class="headerlink" title="根据数据结构分类"></a>根据数据结构分类</h2><p>MySQL的索引是由存储引擎来实现的。</p>
<h3 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h3><p>当人们谈论索引的时候，如果没有特别指明类型，那多半说的是B-Tree索引，它使用B-Tree数据结构来存储数据。</p>
<p><strong>不同存储引擎中的 B-Tree索引：</strong></p>
<p>大多数MySQL引擎都支持这种索引。我们使用术语 “ B-Tree ”是因为MySQL在 <code>CREATE TABLE</code>和其他语句中也使用该关键字。</p>
<p>底层的存储引擎也可能使用不同的存储结构，例如，NDB集群存储引擎内部实际上使用了T-Tree结构存储这种索引， 即使其名字是BTREE ；InnoDB则使用的是B+Tree。</p>
<p>存储引擎以不同的方式使用B-Tree索引，性能也各有不同，各有优劣。例如，MyISAM使用前缀压缩技术使得索引更小，但InnoDB则按照原数据格式进行存储。 再如MyISAM索引通过数据的物理位置引用被索引的行，而InnoDB则根据主键引用被索引的行。</p>
<p>B-Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同。</p>
<p>B-Tree索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层查找。通过比较节点页的值和要查找的值可以找到合适的指针进入下层子节点，这些指针实际上定义了子节点页中值的上限和下限。最终存储引擎要么是找到对应的值，要么该记录不存在。</p>
<p>叶子节点比较特别，它们的指针指向的是被索引的数据，而不是其他的节点页 (不同引擎的“指针”类型不同)。</p>
<h4 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h4><p>我们平时使用最多的InnoDB引擎就是基于B+Tree索引的。</p>
<p>二叉树在数据量较大时，深度过深，不太适合数据库的查询，所以数据库使用了多叉树。</p>
<p><strong>B+Tree 对比 BTree的优点：</strong></p>
<p>一般来说B+Tree比BTree更适合实现外存的索引结构，因为存储引擎的设计专家巧妙的利用了外存（磁盘）的存储结构。</p>
<p>磁盘的最小存储单位是扇区（sector），而操作系统的块（block）通常是整数倍的sector，操作系统以页（page）为单位管理内存，一页（page）通常默认为4K，数据库的页通常设置为操作系统页的整数倍，因此索引结构的节点被设计为一个页的大小，然后利用外存的“预读取”原则，每次读取的时候，把整个节点的数据读取到内存中，然后在内存中查找。</p>
<p>已知内存的读取速度是外存读取I/O速度的几百倍，那么提升查找速度的关键就在于尽可能少的磁盘I/O，那么可以知道，每个节点中的key个数越多，那么树的高度越小，需要I/O的次数越少，因此一般来说B+Tree比BTree更快，因为B+Tree的非叶节点中不存储data，就可以存储更多的key。</p>
<p>可参考文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39860280/article/details/110864822">https://blog.csdn.net/weixin_39860280/article/details/110864822</a></p>
<p>B+树的优点：</p>
<ol>
<li><p>非叶子节点不会带上ROWID，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。</p>
</li>
<li><p>叶子节点之间通过指针来连接，范围扫描将十分简单，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动。</p>
</li>
</ol>
<p>B树的优点：</p>
<p>对于在内部节点的数据，可直接得到，不必根据叶子节点来定位。</p>
<ol>
<li><p>B+-tree的磁盘读写代价更低  B+-tree的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。  举个例子，假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。一棵9阶B-tree(一个结点最多8个关键字)的内部结点需要2个盘快。而B+ 树内部结点只需要1个盘快。当需要把内部结点读入内存中的时候，B 树就比B+ 树多一次盘块查找时间(在磁盘中就是盘片旋转的时间)。 </p>
</li>
<li><p>B+-tree的查询效率更加稳定  由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
</li>
<li><p>“B+树还有一个最大的好处，方便扫库，B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了，B+树支持range-query非常方便，而B树不支持。这是数据库选用B+树的最主要原因。</p>
</li>
</ol>
<h4 id="聚簇索引、一级索引、聚集索引、主键索引"><a href="#聚簇索引、一级索引、聚集索引、主键索引" class="headerlink" title="聚簇索引、一级索引、聚集索引、主键索引"></a>聚簇索引、一级索引、聚集索引、主键索引</h4><p>前段时间看到一个问题：“你知道为什么InnoDB非主键索引普遍比主键索引要慢吗？”答案是InnoDB使用了聚簇索引，主键索引主需要查询一次，而非主键索引需要查询两次。</p>
<p>聚簇索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚集索引的叶子节点称为数据页。这个特性决定了索引组织表中数据也是索引的一部分，每张表只能拥有一个聚簇索引。</p>
<p>Innodb通过主键聚集数据，如果没有定义主键，innodb会选择非空的唯一索引代替。如果没有这样的索引，innodb会隐式的定义一个主键来作为聚簇索引。</p>
<p>优点：</p>
<p>​    1.数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快</p>
<p>　2.聚簇索引对于主键的排序查找和范围查找速度非常快<br>缺点：</p>
<p>　1.插入速度严重依赖于插入顺序，按照主键的<strong>顺序插入</strong>是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个<strong>自增的ID列为主键</strong></p>
<p>​    2.<strong>更新主键的代价很高</strong>，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。</p>
<p>​    3.二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</p>
<h4 id="非聚簇索引、二级索引、辅助索引"><a href="#非聚簇索引、二级索引、辅助索引" class="headerlink" title="非聚簇索引、二级索引、辅助索引"></a>非聚簇索引、二级索引、辅助索引</h4><p>在<strong>聚簇索引之上创建的索引称之为辅助索引</strong>，辅助索引访问数据总是需要二次查找。辅助索引叶子节点存储的不再是行的物理位置，而是主键值。通过辅助索引首先找到的是主键值，再通过主键值找到数据行的数据页，再通过数据页中的Page Directory找到数据行。</p>
<p>辅助索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个辅助索引。在innodb中有时也称辅助索引为二级索引。</p>
<p>聚集索引，表中存储的数据按照索引的顺序存储，检索效率比普通索引高，但对数据新增/修改/删除的影响比较大 </p>
<p>非聚集索引，不影响表中的数据存储顺序,，检索效率比聚集索引低，对数据新增/修改/删除的影响很小</p>
<h5 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h5><p>回到主键索引树搜索的过程，就是回表。</p>
<h5 id="覆盖索引（索引覆盖）"><a href="#覆盖索引（索引覆盖）" class="headerlink" title="覆盖索引（索引覆盖）"></a>覆盖索引（索引覆盖）</h5><p>不过也有方法避免回表，那就是覆盖索引。</p>
<ul>
<li>解释一： 就是select的数据列只用从索引中就能够取得，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。</li>
<li>解释二： 索引是高效找到行的一个方法，当能通过检索索引就可以读取想要的数据，那就不需要再到数据表中读取行了。如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫做覆盖索引。</li>
<li>解释三：是非聚集组合索引的一种形式，它包括在查询里的Select、Join和Where子句用到的所有列（即建立索引的字段正好是覆盖查询语句[select子句]与查询条件[Where子句]中所涉及的字段，也即，索引包含了查询正在查找的所有数据）。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36344771/article/details/105547442">https://blog.csdn.net/qq_36344771/article/details/105547442</a></p>
<h4 id="联合索引、多列索引、组合索引"><a href="#联合索引、多列索引、组合索引" class="headerlink" title="联合索引、多列索引、组合索引"></a>联合索引、多列索引、组合索引</h4><p>联合索引也是一颗B+树，不同的是联合索引的键值的数量不是1，而是大于等于2。</p>
<h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>哈希索引（hash index）基于哈希表实现，只有精确匹配到索引所有列的查询才有效。</p>
<p>对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。 </p>
<p>MySql 最常用存储引擎 InnoDB 和 MyISAM 都不支持 Hash 索引，它们默认的索引都是 B-Tree。但是如果你在创建索引的时候定义其类型为 Hash，MySql 并不会报错，而且你通过 SHOW CREATE TABLE 查看该索引也是 Hash，只不过该索引实际上还是 B-Tree。</p>
<p>但 InnoDB 有另一种实现方法：自适应哈希索引。</p>
<h5 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h5><p>InnoDB引擎有一个特殊的功能叫做 “自适应哈希索引（adaptive hash index）”，当innodb注意到某些索引值被使用的非常频繁时，它会在内存中基于btree索引之上再创建一个哈希索引，这样就让btree索引也具有哈希索引的一些优点，比如：快速的哈希查找，这是一个全自动的，内部的行为，用户无法控制或者配置，不过如果有必要，可以选择关闭这个功能（innodb_adaptive_hash_index=OFF，默认为ON）。</p>
<h5 id="自定义哈希索引"><a href="#自定义哈希索引" class="headerlink" title="自定义哈希索引"></a>自定义哈希索引</h5><h3 id="全文索引-1"><a href="#全文索引-1" class="headerlink" title="全文索引"></a>全文索引</h3><p>全文索引是一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值。</p>
<p>innodb 从1.2.x 开始才增加了全文索引支持。</p>
<h4 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h4><p>倒排索引源于实际应用中需要根据属性的值来查找记录。</p>
<p>这种索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址。</p>
<p>由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因而称为倒排索引（inverted index）。带有倒排索引的文件我们称为倒排索引文件，简称倒排文件。</p>
<h3 id="空间数据索引（R-Tree）"><a href="#空间数据索引（R-Tree）" class="headerlink" title="空间数据索引（R-Tree）"></a>空间数据索引（R-Tree）</h3><p>MyISAM表支持空间索引，可以用作地理数据存储。</p>
<p>和B-Tree不同，空间索引无须前缀查询。</p>
<p>空间索引会从所有维度来索引数据。</p>
<h3 id="分形树索引"><a href="#分形树索引" class="headerlink" title="分形树索引"></a>分形树索引</h3><h2 id="索引失效的情况（SQL优化）"><a href="#索引失效的情况（SQL优化）" class="headerlink" title="索引失效的情况（SQL优化）"></a>索引失效的情况（SQL优化）</h2><p><strong>对查询进行优化,尽量避免全表扫描,避免导致索引失效</strong></p>
<ol>
<li><p>在where子句中进行null值判断的话会导致引擎放弃索引而产生全表扫描</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT id FROM table WHERE num is null</span><br><span class="line"></span><br><span class="line">在建立数据库的时候因尽量为字段设置默认值，如int类型可以使用0，varchar类型使用 &#x27;&#x27;</span><br><span class="line">当你在指定类型大小如int(11)时，其实空间就已经固定了，即使存的是null也是这个大小</span><br></pre></td></tr></table></figure></li>
<li><p>避免在where子句中使用<code>!= ,&lt; &gt;</code>这样的符号，否则会导致引擎放弃索引而产生全表扫描。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id FROM table WHERE num != 0</span><br></pre></td></tr></table></figure></li>
<li><p>避免在where子句中使用<code>or</code>来连接条件,<strong>因为如果俩个字段中有一个没有索引的话,引擎会放弃索引而产生全表扫描</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id FROM table WHERE num = 0 OR num = 1</span><br></pre></td></tr></table></figure></li>
<li><p>可以考虑使用<code>between</code>,但是只能是连续的数值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id FROM table WHERE num BETWEEN 0 AND 1</span><br></pre></td></tr></table></figure></li>
<li><p>避免在where子句中使用<code>in</code>关于网上说的MySQL在使用<code>in</code>不走索引的问题,严谨的来说的话分为俩种情况</p>
<ul>
<li><ul>
<li><p>走索引的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id FROM table WHERE num IN (1)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ul>
<li><p>不走索引的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id FROM table WHERE num IN (1,2)其实在in里面,如果只有一个值的话是等价于num = 1的</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>避免在where子句中<code>=</code>的左边使用表达式操作或者函数操作</p>
<ul>
<li><ul>
<li>表达式</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> num <span class="operator">/</span> <span class="number">2</span> <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li>函数操作</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id FROM table WHERE SUBSTRING(name,1,2) = &#x27;wise&#x27;</span><br></pre></td></tr></table></figure></li>
<li><p>在使用联合索引是要注意<strong>最左原则</strong>，例如如果当前联合索引是<code>index(a,b,c)</code>，那么如果where子句中有<code>a</code>就会用到联合索引，但是如果只用到<code>b,c</code>就会失去索引效果。</p>
</li>
<li><p>避免在where子句中使用<code>like</code>模糊查询。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;wise&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="慢查询优化"><a href="#慢查询优化" class="headerlink" title="慢查询优化"></a>慢查询优化</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32002253/article/details/86772940">https://blog.csdn.net/qq_32002253/article/details/86772940</a></p>
<h3 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h3><p>MySQL会一直向右匹配直到遇到范围查询（&gt;,&lt;,BETWEEN,LIKE）就停止匹配。</p>
<ul>
<li>索引可以简单如一个列 (a)，也可以复杂如多个列 (a,b,c,d)，即联合索引。</li>
<li>如果是联合索引，那么key也由多个列组成，同时，索引只能用于查找key是否存在（相等），遇到范围查询 (&gt;、&lt;、between、like左匹配)等就不能进一步匹配了，后续退化为线性查找。</li>
<li>因此，列的排列顺序决定了可命中索引的列数。</li>
</ul>
<p>如有索引 (a,b,c,d)，查询条件 a=1 and b=2 and c&gt;3 and d=4，则会在每个节点依次命中a、b、c，无法命中d。(c已经是范围查询了，d肯定是排不了序了)</p>
<h2 id="索引常见问题"><a href="#索引常见问题" class="headerlink" title="索引常见问题"></a>索引常见问题</h2><p><strong>数据库有几千万的数据，查询⼜很慢我们怎么办？</strong></p>
<p>加索引</p>
<p><strong>索引有哪些数据结构？</strong></p>
<p>Hash、B+</p>
<p><strong>为什么哈希表、完全平衡二叉树、B树、B+树都可以优化查询，为何Mysql独独喜欢B+树？</strong></p>
<p>哈希表的特点就是可以快速的精确查询，但是不支持范围查询。</p>
<p><strong>Hash表在哪些场景比较适合？</strong></p>
<p>等值查询的场景，就只有KV（Key，Value）的情况，例如Redis、Memcached等这些NoSQL的中间件。</p>
<p><strong>你说的是无序的Hash表，那有没有有序的数据结构？</strong></p>
<p>有序数组：等值查询的和范围查询的时侯都很好，</p>
<p>有序的适合静态数据，因为如果我们新增、删除、修改数据的时候就会改变他的结构。比如你新增一个，那在你新增的位置后面所有的节点都会后移，成本很高。</p>
<p>可以用来做静态存储引擎啊，用来保存静态数据，例如你2019年的支付宝账单，2019年的淘宝购物记录等等都是很合适的，都是不会变动的历史数据</p>
<p><strong>那二叉树呢？</strong></p>
<p>二叉树是有序的，所以是支持范围查询的。但是他的时间复杂度是O(log(N))，为了维持这个时间复杂度，更新的时间复杂度也得是O(log(N))，那就得保持这棵树是完全平衡二叉树了</p>
<p><strong>如果用B树呢？</strong></p>
<p>可以发现同样的元素，B树的表示要比完全平衡二叉树要“矮”，原因在于B树中的一个节点可以存储多个元素。B树其实就已经是一个不错的数据结构，用来做索引效果还是不错的。</p>
<p><strong>那为啥没用B树，而用了B+树？</strong></p>
<p>我们可以发现同样的元素，B+树的表示要比B树要“胖”，原因在于B+树中的非叶子节点会冗余一份在叶子节点中，并且叶子节点之间用指针相连。</p>
<p><strong>那么B+树到底有什么优势呢？</strong></p>
<p>而B+树是B树的升级版，只是把非叶子节点冗余一下，这么做的好处是为了提高范围查找的效率。提高了的原因也无非是会有指针指向下一个节点的叶子节点</p>
<p>Mysql选用B+树这种数据结构作为索引，可以提高查询索引时的磁盘IO效率，并且可以提高范围查询的效率，并且B+树里的元素也是有序的</p>
<p>b+树中的主键索引和普通索引的叶子结点有啥区别<br>b+树中的主键索引和唯一索引的叶子结点的区别</p>
<p>MySQL索引种类，如何指定日期范围以内的记录数</p>
<p>如果表中有一个字段，如手机号是唯一的，怎么建立索引</p>
<h1 id="事务（Transaction）"><a href="#事务（Transaction）" class="headerlink" title="事务（Transaction）"></a>事务（Transaction）</h1><h2 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a><strong>什么是事务？</strong></h2><p>事务是数据库区别于文件系统的重要特性之一。</p>
<h2 id="引入事务的目的"><a href="#引入事务的目的" class="headerlink" title="引入事务的目的"></a>引入事务的目的</h2><p>引入事务的主要目的：事务会把数据库从一种一致性状态转换为另一种一致性状态。</p>
<h2 id="ACID特性"><a href="#ACID特性" class="headerlink" title="ACID特性"></a>ACID特性</h2><p>InnoDB存储引擎的事务完全符合ACID的特性：</p>
<ul>
<li><p><strong>原子性</strong>（atomicity）</p>
<p>原子性是指整个数据库事务是不可分割的工作单位。只有使事务中所有的数据库操作都执行成功，才算整个事务成功。事务中任何一个SQL语句执行失败，已经执行成功的SQL语句也必须撤销，数据库状态应该退回到执行事务前的状态。</p>
</li>
<li><p><strong>一致性</strong>（consistency）</p>
<p>一致性指事务将数据库从一种状态转变为下一种一致的状态。在事务开始前和事务结束以后，数据库的完整性约束没有被破坏。</p>
</li>
<li><p><strong>隔离性</strong>（isolation）</p>
<p>隔离性，也被称为并发控制（concurrency control）、可串行化（serializability）、锁（locking）等。</p>
<p>事务的隔离性要求每个读写事务的对象对其他事务的操作对象能相互分离，即该事务提交前对其他事务都不可见。</p>
<p><strong>粒度锁策略</strong>允许事务仅锁住一个实体对象的子集，以此来提高事务之间的并发性。</p>
</li>
<li><p><strong>持久性</strong>（durability）</p>
<p>事务一旦提交，其结果就是永久的。</p>
<p>持久性保证事务系统的高可靠性（High Reliability），而不是高可用性（High Availability）。</p>
</li>
</ul>
<h2 id="事务的分类"><a href="#事务的分类" class="headerlink" title="事务的分类"></a>事务的分类</h2><p>从事务理论的角度来说，可以把事务分为以下几类：</p>
<ul>
<li><p>扁平事务（Flat Transactions）</p>
<p>是事务类型种最简单的一种，也是实际生成环境种可能使用最频繁的一种。</p>
<p>扁平事务中，所有操作都处于同一层次，由<code>BEGIN WORK</code>开始，到 <code>COMMIT WORK</code> 或 <code>ROLLBACK WORK</code> 结束，其间的操作是原子的，要么都执行，要么都回滚。</p>
<p>主要限制是不能提交或回滚事务的某一部分，或分几个步骤提交。</p>
</li>
<li><p>带有保存点的扁平事务（Flat Transactions with Savepoints）</p>
<p>除了支持扁平事务，允许事务执行过程中回滚到同一事务较早的一个状态。</p>
<p>保存点（Save Point）用来通知系统应该记住事务当前的状态，以便当之后发生错误时，事务能回到保存点当时的状态。</p>
<p>保存点用 <code>SAVE WORK</code> 函数来建立，通知系统记录当前的处理状态。</p>
<p>扁平的事务隐式地设置了一个保存点，也只有这一个保存点。</p>
<p>保存点在事务内部是递增的。</p>
<p>保存点是易失的。</p>
</li>
<li><p>链事务（Chained Transactions）</p>
<p>链事务可以视为保存点模式的一种变种。</p>
<p>链事务的思想：在提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式地传给下一个要开始的事务。</p>
<p>链事务与带有保存点的扁平事务的不同：</p>
<ul>
<li><p>链事务的回滚仅限于当前事务，即只能回复到最近的一个保存点，而带有保存点的扁平事务能回滚到任意正确的保存点。</p>
</li>
<li><p>两者对于锁的处理也不同。链事务在执行 COMMIT 后即释放了当前事务所持有的锁，而带有保存点的扁平事务不影响迄今为止所持有的所。</p>
</li>
</ul>
</li>
<li><p>嵌套事务（Nested Transactions）</p>
<p>嵌套事务时一个层次结构框架。由一个<strong>顶层事务</strong>（top-level transaction）控制这各个层次的事务。顶层事务之下嵌套的事务被称为<strong>子事务</strong>，其控制着每一个局部的变换。</p>
<p><strong>Moss对嵌套事务的定义：</strong></p>
<ol>
<li>嵌套事务是由若干事务组成的一棵树， 子树既可以是嵌套事务，也可以是扁平事务。</li>
<li>处在叶节点的事务是扁平事务。但是每个子事务从根到叶节点的距离可以是不同的。</li>
<li>位于根节点的事务称为顶层事务，其他事务称为子事务。事务的前驱称（predecessor）为父事务（parent）， 事务的下一层称为儿子事务（child）。</li>
<li>子事务既可以提交也可以回滚。但是它的提交操作并不马上生效，除非其父事务已经提交。因此可以推论出，<strong>任何子事务都在顶层事务提交后才真正的提交。</strong></li>
<li>树中的任意一个事务的回滚会引起它的所有子事务一同回滚，故<strong>子事务仅保留A、C、I特性，不具有D的特性</strong>。</li>
</ol>
<p>实际的工作是交由叶子节点来完成的，即只有叶子节点的事务才能访问数据库、发送消息、获取其他类型的资源。而高层的事务仅负责控制逻辑，决定和是调用相关的子事务。</p>
<p>即使一个系统不支持嵌套事务，也可以通过保存点技术来模拟嵌套事务。二者的区别是：</p>
<ul>
<li>在恢复时采用保存点技术比嵌套传有更大的灵活性。</li>
<li>锁的持有方面不同。使用保存点技术模拟嵌套事务时，用户无法选择哪些锁需要被子事务继承，哪些需要被父事务保留；而在嵌套查询中，不同的子事务在数据库对象上持有的锁是不同的。</li>
</ul>
</li>
<li><p>分布式事务（Distrubuted Transactions）</p>
<p>分布式事务通常是一个在分布式环境下运行的扁平事务，需要根据数据所在位置访问网络中的不同节点。</p>
</li>
</ul>
<p>对于InnoDB存储引擎来说，其支持扁平事务、带有保存点的事务、链事务、分布式事务。对于嵌套事务，并不原生支持，需要通过带有保存点的事务来模拟串行的嵌套事务。</p>
<h2 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h2><p>隔离性（Isolation）由锁来实现</p>
<p>原子性（Atomicity）和持久性（Durability）由 <strong>redo log</strong>（重做日志）来保证。</p>
<p>一致性（Consistency）由 <strong>undo log</strong> 来保证。</p>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>SQL 标准定义了4类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。<br><strong>Read Uncommitted（读取未提交内容）</strong></p>
<p>Read Uncommitted 称为浏览访问（browse access），仅仅针对事务而言。</p>
<p>在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为<strong>脏读</strong>（Dirty Read）。<br><strong>Read Committed（读取提交内容）</strong></p>
<p>Read Commited 称为游标稳定（cursor stability）。这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。</p>
<p>一个事务只能看见已经提交事务所做的改变。这种隔离级别也造成 <strong>不可重复读</strong>（Nonrepeatable  Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。<br><strong>Repeatable Read（可重读）</strong></p>
<p>这是 InnoDB存储引擎的<strong>默认事务隔离级别</strong></p>
<p>它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。</p>
<p>不过理论上，这会导致另一个棘手的问题：<strong>幻读</strong>  （Phantom  Read）。幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的 “幻影”  行。</p>
<p>InnoDB 和 Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency  Control）机制解决了该问题。</p>
<p>InnoDB存储引擎在 Repeatable Read 事务隔离级别下，使用Next-Key Lock 锁的算法，避免幻读的产生。所以，InnoDB存储引擎在默认的 Reapeatable Read的事务隔离级别下已经能完全保证事务的隔离性要求，即达到 SQL 标准的 Serialiazble 隔离级别。</p>
<p><strong>Serializable（可串行化）</strong><br>称为隔离，是SQL 和 SQL2 标准的默认事务隔离级别，是<strong>最高的隔离级别</strong>。</p>
<p>它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="第一类丢失更新（Lost-Update）"><a href="#第一类丢失更新（Lost-Update）" class="headerlink" title="第一类丢失更新（Lost Update）"></a>第一类丢失更新（Lost Update）</h3><p>在完全未隔离事务的情况下，两个事务更新同一条数据资源，某一事务完成，另一事务异常终止，回滚造成第一个完成的更新也同时丢失 。这个问题现代关系型数据库已经不会发生。</p>
<h3 id="脏读（Dirty-Read）"><a href="#脏读（Dirty-Read）" class="headerlink" title="脏读（Dirty Read）"></a>脏读（Dirty Read）</h3><p>A事务执行过程中，B事务读取了A事务的修改。但是由于某些原因，A事务可能没有完成提交，发生RollBack了操作，则B事务所读取的数据就会是不正确的。这个未提交数据就是脏读（Dirty Read）。</p>
<p><strong>读取提交内容隔离级别</strong>解决脏读问题。</p>
<h3 id="不可重复读（Nonrepeatable-Read）"><a href="#不可重复读（Nonrepeatable-Read）" class="headerlink" title="不可重复读（Nonrepeatable Read）"></a>不可重复读（Nonrepeatable Read）</h3><p>B事务读取了两次数据，在这两次的读取过程中A事务修改了数据，B事务的这两次读取出来的数据不一样。B事务这种读取的结果，即为不可重复读（Nonrepeatable Read）。</p>
<h3 id="第二类丢失更新"><a href="#第二类丢失更新" class="headerlink" title="第二类丢失更新"></a>第二类丢失更新</h3><p>不可重复读有一种特殊情况，两个事务更新同一条数据资源，后完成的事务会造成先完成的事务更新丢失。</p>
<p><strong>可重复读隔离级别</strong>解决第二类丢失更新和不可重复读问题。</p>
<h3 id="幻读（Phantom-Read）"><a href="#幻读（Phantom-Read）" class="headerlink" title="幻读（Phantom Read）"></a>幻读（Phantom Read）</h3><p>B事务读取了两次数据，在这两次的读取过程中A事务添加了数据，B事务的这两次读取出来的集合不一样。</p>
<p><strong>可串行化隔离级别</strong>解决幻读问题。</p>
<p><img src="7.%E6%95%B0%E6%8D%AE%E5%BA%93.assets/42655-20190222000420486-835926543.png" alt="20160319184334938"></p>
<h1 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h1><h2 id="什么是锁？"><a href="#什么是锁？" class="headerlink" title="什么是锁？"></a>什么是锁？</h2><h2 id="使用锁的目的"><a href="#使用锁的目的" class="headerlink" title="使用锁的目的"></a>使用锁的目的</h2><p>锁机制用于管理对共享资源的并发访问。</p>
<h2 id="锁粒度"><a href="#锁粒度" class="headerlink" title="锁粒度"></a>锁粒度</h2><p>锁粒度就是通常我们所说的锁级别。</p>
<p><strong>MySQL有三种锁的级别：页级、表级、行级</strong></p>
<ul>
<li>MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking）</li>
<li>BDB存储引擎采用的是页面锁（page-level locking），但也支持表级锁；</li>
<li>InnoDB存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。</li>
</ul>
<p><strong>特性：</strong>：</p>
<ul>
<li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</li>
<li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</li>
<li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li>
</ul>
<p><strong>数据库引擎通常必须获取多粒度级别上的锁才能完整地保护资源。</strong> 这组多粒度级别上的锁称为<strong>锁层次结构</strong>。 例如，为了完整地保护对索引的读取，数据库引擎实例可能必须获取行上的共享锁以及页和表上的意向共享锁。</p>
<h2 id="各存储引擎中的锁实现"><a href="#各存储引擎中的锁实现" class="headerlink" title="各存储引擎中的锁实现"></a>各存储引擎中的锁实现</h2><p>InnoDB存储引擎会在行级别上对表数据上锁。</p>
<p>MyISAM存储引擎的锁是表锁设计。</p>
<h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><h3 id="lock-和-latch"><a href="#lock-和-latch" class="headerlink" title="lock 和 latch"></a>lock 和 latch</h3><p>lock和latch都可以被称为 ”锁“，但是两者有着截然不同的含义。此处主要关注 lock。</p>
<p><strong>latch</strong></p>
<p>latch一般称为闩锁（轻量级的锁），其要求的锁定的时间非常短。</p>
<p>在 InnoDB 存储引擎中，latch又可以分为<code>mutex</code>（互斥量）和 <code>rwlock</code>（读写锁）。</p>
<p>其目的是保证并发线程操作临界资源的正确性，并且通常没有死锁检测的机制。</p>
<p><strong>lock</strong></p>
<p>lock的对象是事务，用来锁定的是数据库中的对象，如表、页、行。</p>
<p>一般lock的对象仅在事务 commit 和 rollback 后进行释放（不同事务隔离级别释放的时间可能不同）。</p>
<p>lock是有死锁机制的。</p>
<p><strong>lock和latch的区别</strong></p>
<p><img src="7.%E6%95%B0%E6%8D%AE%E5%BA%93.assets/20201207103106902.png" alt="在这里插入图片描述"></p>
<h3 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h3><p>InnoDB存储引擎实现了两种标准的行级锁：</p>
<ul>
<li><p>共享锁（S Lock），允许事务读一行数据。</p>
</li>
<li><p>排他锁（X Lock），允许事务删除或更新一行数据。</p>
</li>
</ul>
<p>锁兼容（Lock Compatible）</p>
<p>锁不兼容</p>
<p>X锁与任何的锁都不兼容，S锁仅与S锁兼容。</p>
<p>S锁和X锁都是行锁，兼容是指对同一记录（row）的兼容性情况。</p>
<p>多粒度（granular）锁定：允许事务在行级上的锁和表级上的锁同时存在。</p>
<h4 id="共享锁（读锁）"><a href="#共享锁（读锁）" class="headerlink" title="共享锁（读锁）"></a><strong>共享锁（读锁）</strong></h4><p>共享锁（S锁）：共享 (S) 用于不更改或不更新数据的操作（只读操作），如 SELECT 语句。</p>
<p>如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获准共享锁的事务<strong>只能读数据，不能修改数据</strong>。</p>
<h4 id="排他锁（写锁）"><a href="#排他锁（写锁）" class="headerlink" title="排他锁（写锁）"></a><strong>排他锁（写锁）</strong></h4><p>排他锁（X锁）：用于数据修改操作，例如 INSERT、UPDATE 或 DELETE。确保不会同时同一资源进行多重更新。</p>
<p>如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获准排他锁的事务<strong>既能读数据，又能修改数据</strong>。</p>
<p>我们在操作数据库的时候，可能会由于并发问题而引起的数据的不一致性（数据冲突）</p>
<h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a><strong>意向锁</strong></h4><p>将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁。</p>
<p>InnoDB存储引擎中的意向锁设计比较简练，其意向锁即为表级别的锁。</p>
<p>设计目的是为了在下一个事务中揭示下一行将被请求的锁类型。</p>
<p>其支持两种意向锁：</p>
<p><strong>意向共享锁（IS Lock）：</strong>事务想要获得一张表中某几行的共享锁。</p>
<p><strong>意向排他锁（IX Lock）：</strong>事务想要获得一张表中某几行的排他锁。</p>
<h3 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h3><h3 id="一致性锁定读"><a href="#一致性锁定读" class="headerlink" title="一致性锁定读"></a>一致性锁定读</h3><h3 id="自增长与锁"><a href="#自增长与锁" class="headerlink" title="自增长与锁"></a>自增长与锁</h3><h3 id="外键和锁"><a href="#外键和锁" class="headerlink" title="外键和锁"></a>外键和锁</h3><h2 id="锁的算法"><a href="#锁的算法" class="headerlink" title="锁的算法"></a>锁的算法</h2><p>Record Lock：</p>
<p>Gap Lock：</p>
<p>Next-Key Lock：Gap Lock + Record Lock</p>
<h2 id="锁问题"><a href="#锁问题" class="headerlink" title="锁问题"></a>锁问题</h2><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><h3 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h3><p>幻读</p>
<h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h2 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h2><ol>
<li>进行排列。可以做排行榜应用，取TOP N操作。</li>
</ol>
<h2 id="并发控制-1"><a href="#并发控制-1" class="headerlink" title="并发控制"></a>并发控制</h2><p>数据库并发场景有三种，分别为：</p>
<p>读-读：不存在任何问题，也不需要并发控制<br>读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读<br>写-写：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失</p>
<ul>
<li><code>MVCC + 悲观锁</code><br>MVCC解决读写冲突，悲观锁解决写写冲突</li>
<li><code>MVCC + 乐观锁</code><br>MVCC解决读写冲突，乐观锁解决写写冲突</li>
</ul>
<h3 id="悲观并发控制（悲观锁）"><a href="#悲观并发控制（悲观锁）" class="headerlink" title="悲观并发控制（悲观锁）"></a>悲观并发控制（悲观锁）</h3><p>在关系数据库管理系统里，悲观并发控制（悲观锁，Pessimistic Concurrency Control，PCC）是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。</p>
<p>如果一个事务执行的操作对某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。</p>
<p>悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。</p>
<p>悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度（悲观），因此，在整个数据处理过程中，将数据处于锁定状态。 悲观锁的实现，往往依靠数据库提供的锁机制 （也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</p>
<p><strong>在数据库中，悲观锁的流程如下：</strong></p>
<ol>
<li>在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。</li>
<li>如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。</li>
<li>如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。</li>
<li>其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。</li>
</ol>
<p><strong>优点与不足：</strong></p>
<p>悲观并发控制实际上是 “ 先取锁再访问 “ 的保守策略，为数据处理的安全提供了保证。</p>
<p>不足：</p>
<p>在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；</p>
<p>在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；</p>
<p>降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数</p>
<h3 id="乐观并发控制（乐观锁）"><a href="#乐观并发控制（乐观锁）" class="headerlink" title="乐观并发控制（乐观锁）"></a>乐观并发控制（乐观锁）</h3><p>在关系数据库管理系统里，乐观并发控制（乐观锁，Optimistic Concurrency Control，OCC）是一种并发控制的方法。</p>
<p>它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。乐观事务控制最早是由孔祥重（H.T.Kung）教授提出。</p>
<p>乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。</p>
<p><strong>乐观锁的实现：</strong></p>
<p>相对于悲观锁，在对数据库进行处理的时候，<strong>乐观锁并不会使用数据库提供的锁机制</strong>。</p>
<p>一般的实现乐观锁的方式就是<strong>记录数据版本</strong>。</p>
<p>数据版本，为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。</p>
<p>实现数据版本有两种方式，第一种是使用<strong>版本号</strong>，第二种是使用<strong>时间戳</strong>。</p>
<p><strong>使用版本号实现乐观锁：</strong></p>
<p>使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。</p>
<p><strong>优点与不足：</strong></p>
<p>乐观并发控制相信事务之间的数据竞争（data race）的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。</p>
<h3 id="多版本并发控制（MVCC）"><a href="#多版本并发控制（MVCC）" class="headerlink" title="多版本并发控制（MVCC）"></a>多版本并发控制（MVCC）</h3><p>多版本并发控制（MVCC，Multi-Version Concurrency Control）是一种用来解决<strong>读-写冲突</strong>的<strong>无锁并发控制</strong></p>
<p>MySQL的大多数事务型存储引擎实现的都不是简单的行级锁。基于提升并发性能的考虑，它们一般都实现了多版本并发控制（MVCC）。</p>
<p>可以认为MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作，写操作也只锁定必要的行。</p>
<p><strong>实现：</strong></p>
<p>MVCC是通过保存数据在某个时间点的<strong>快照</strong>来实现的。</p>
<p>不管事务需要执行多长时间，每个事务看到的数据都是一致的。</p>
<p>根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。</p>
<p>不同存储引擎的MVCC实现是不同的，典型的有<strong>乐观并发控制</strong>和<strong>悲观并发控制</strong>。</p>
<p><strong>InnoDB中的MVCC实现：</strong></p>
<p>InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。</p>
<p>这两个列，一个保存了行的创建时间，一个保存了行的过期时间（或删除时间）。</p>
<p>当然，存储的并不是实际的时间值，而是系统版本号（system version number）。每开始一个新的事务，系统版本号会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p>
<p><strong>在Reapeatable read隔离级别下，MVCC的具体操作：</strong></p>
<ul>
<li><p>SELECT</p>
<p>InnoDB会根据以下两个条件检查每行记录：</p>
<ul>
<li>InnoDB只查找版本早于当前事务版本的数据行（也就是，行的系统版本号 &lt;= 事务的系统版本号），这样就可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。</li>
<li>行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。</li>
</ul>
<p>只有符合上述两个条件的记录，才能返回作为查询结果。</p>
</li>
<li><p>INSERT</p>
<p>InnoDB为新插入的每一行保存当前系统版本号作为行版本号。</p>
</li>
<li><p>DELETE</p>
<p>InnoDB为删除的每一行保存当前系统版本号作为行删除标识。</p>
</li>
<li><p>UPDATE</p>
<p>InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。</p>
</li>
</ul>
<p>保存这两个额外系统版本号，使大多数操作都可以不同加锁。使得读数据操作加拿大你，性能很好，并且也能保证只会读取到符合标准的行。</p>
<p>不足之处是每行记录都需要额外的存储空间，需要做更多行检查工作，以及一些额外的维护工作。</p>
<p>MVCC只在repeatable read 和 read committed 两个隔离级别下工作。其他两个隔离级别都和MVCC不兼容。因为 read uncommitted 总是都组最新的数据行，而不是符合当前事务版本的数据行。而 serializable则会对所有读取的行都加锁。</p>
<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h2 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h2><p>InnoDB存储引擎是第一个完整支持ACID事务的MySQL存储引擎。</p>
<p>特点为<strong>行锁设计</strong>、<strong>支持MVCC</strong>、<strong>支持外键</strong>、<strong>提供一致性非锁定读</strong>、被设计用来<strong>最有效地利用以及使用内存和CPU</strong>。</p>
<h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h3><p>InnoDB存储引擎有多个内存块，可以认为这些内存块组成了一个大的内存池，负责以下工作：</p>
<ul>
<li>维护所有进程/线程需要访问的多个内部存储结构</li>
<li>缓存磁盘上的数据，方便快速地读取，同时在对磁盘文件的数据修改之前在这里缓存。</li>
<li>重做日志（redo log）缓冲。‘</li>
</ul>
<p>独占锁</p>
<p>读锁</p>
<p>写锁</p>
<p>意向锁</p>
<p>共享锁</p>
<p>排他锁</p>
<p>意向共享锁</p>
<p>意向排他锁</p>
<p>悲观锁</p>
<p>乐观锁</p>
<p>锁升级</p>
<p>死锁</p>
<p>粒度锁</p>
<p>间隙锁</p>
<p>锁兼容</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/25/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-id="ckp3gdqh70002poup4js9dxpv" data-title="MySQL学习笔记" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-JVM学习笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/25/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2021-05-25T02:27:37.000Z" itemprop="datePublished">2021-05-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/25/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">JVM学习笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h1><p>JVM 内存布局规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行。不同的 JVM 对于内存的划分方式和管理机制存在着部分差异。</p>
<p>Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区域，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程一一对应的数据区域会随着线程开始和结束而创建和销毁。</p>
<ul>
<li><strong>线程私有</strong>：程序计数器、虚拟机栈、本地方法栈</li>
<li><strong>线程共享</strong>：堆、方法区（堆外内存，Java7的永久代，JDK8的元空间，代码缓存））</li>
</ul>
<p>Java虚拟机所管理的内存将会包括以下几个运行时数据区域</p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器（Program Counter Register，PC 寄存器）是一块较小的内存空间，可以看作是当前线程所执行的字节码的<strong>行号指示器</strong></p>
<p>PC 寄存器用来存储指向下一条指令的地址，即将要执行的指令代码。由执行引擎读取下一条指令。</p>
<ul>
<li><strong>使用PC寄存器存储字节码指令地址有什么用呢？为什么使用PC寄存器记录当前线程的执行地址呢？</strong></li>
</ul>
<p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p>
<ul>
<li><strong>PC寄存器为什么会被设定为线程私有的？</strong></li>
</ul>
<p>多线程在一个特定的时间段内只会执行其中某一个线程方法，CPU会不停的做任务切换，这样必然会导致经常中断或恢复。为了能够准确的记录各个线程正在执行的当前字节码指令地址，所以为每个线程都分配了一个PC寄存器，每个线程都独立计算，不会互相影响。</p>
<p><strong>总结</strong></p>
<ul>
<li>它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域</li>
<li>在 JVM 规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期一致</li>
<li>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。如果当前线程正在执行的是 Java 方法，程序计数器记录的是<strong>虚拟机字节码指令地址</strong>，如果是执行 <strong>native 方法</strong>，计数器值则应为<strong>空（Undefined）</strong></li>
<li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成</li>
<li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</li>
<li><strong>它是唯一一个在 JVM 规范中没有规定任何 <code>OutOfMemoryError</code> 情况的区域</strong></li>
</ul>
<h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>Java 虚拟机栈（Java Virtual Machine Stack），早期也叫 Java 栈。每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame），对应着一次次 Java 方法调用，是<strong>线程私有</strong>的，生命周期和线程一致。</p>
<p><strong>作用：</strong>虚拟机栈描述Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机会同步创建一个栈帧（Stack Frame），用于存储局部变量表、操作数栈、动态连接、方法出口等信息。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器</li>
<li>直接对虚拟机栈的操作只有两个：每个方法执被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈从入栈到出栈的过程。</li>
<li><strong>栈不存在垃圾回收问题</strong></li>
</ul>
<p><strong>存储单位</strong></p>
<ul>
<li>每个线程都有自己的栈，栈中的数据都是以<strong>栈帧（Stack Frame）的格式存在</strong></li>
<li>在这个线程上正在执行的每个方法都各自有对应的一个栈帧</li>
<li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息</li>
</ul>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p><strong>本地方法接口</strong></p>
<p>一个 Native Method 就是一个 Java 调用非 Java 代码的接口。</p>
<p>Java 使用起来非常方便，然而有些层次的任务用 Java 实现起来也不容易，或者我们对程序的效率很在意时，问题就来了</p>
<ul>
<li>与 Java 环境外交互：有时 Java 应用需要与 Java 外面的环境交互，这就是本地方法存在的原因。</li>
<li>与操作系统交互：JVM 支持 Java 语言本身和运行时库，但是有时仍需要依赖一些底层系统的支持。通过本地方法，我们可以实现用 Java 与实现了 jre 的底层系统交互， JVM 的一些部分就是 C 语言写的。</li>
<li>Sun’s Java：Sun的解释器就是C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分都是用 Java 实现的，它也通过一些本地方法与外界交互。比如，类 <code>java.lang.Thread</code> 的 <code>setPriority()</code> 的方法是用Java 实现的，但它实现调用的是该类的本地方法 <code>setPrioruty()</code>，该方法是C实现的，并被植入 JVM 内部。</li>
</ul>
<p><strong>本地方法栈（Native Method Stack）</strong></p>
<p>Java 虚拟机栈用于管理 Java 方法的调用，而本地方法栈用于管理本地方法的调用</p>
<p>本地方法栈也是<strong>线程私有</strong>的</p>
<p>允许线程固定或者可动态扩展的内存大小</p>
<ul>
<li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java 虚拟机将会抛出一个 <code>StackOverflowError</code> 异常</li>
<li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么 Java虚拟机将会抛出一个<code>OutofMemoryError</code>异常</li>
</ul>
<p>本地方法是使用 C 语言实现的</p>
<p>它的具体做法是 <code>Mative Method Stack</code> 中登记 native 方法，在 <code>Execution Engine</code> 执行时加载本地方法库当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</p>
<p>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区，它甚至可以直接使用本地处理器中的寄存器，直接从本地内存的堆中分配任意数量的内存</p>
<p>并不是所有 JVM 都支持本地方法。因为 Java 虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果 JVM 产品不打算支持 native 方法，也;可以无需实现本地方法栈</p>
<p>在 Hotspot JVM 中，直接将本地方栈和虚拟机栈合二为一</p>
<h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><blockquote>
<p><strong>栈是运行时的单位，而堆是存储的单位</strong>。</p>
<p>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪。</p>
</blockquote>
<p>对于大多数应用，Java 堆是 Java 虚拟机管理的<strong>内存最大的一块</strong>，被<strong>所有线程共享</strong>，在<strong>虚拟机启动时创建</strong>。此内存区域的唯一目的就是<strong>存放对象实例</strong>，几乎所有的对象实例以及数据都在这里分配内存。</p>
<p>Java堆是垃圾收集器管理的内存区域，因此也被称作 <strong>GC堆</strong>。</p>
<p>如果堆中没有完成实例分配，并且堆无法再扩展时，就会抛出 <code>OutOfMemoryError</code> 异常。</p>
<p>为了进行高效的垃圾回收，虚拟机把堆内存<strong>逻辑上</strong>划分成三块区域（分代的唯一理由就是优化 GC 性能）：</p>
<ul>
<li>新生带（年轻代）：新对象和没达到一定年龄的对象都在新生代</li>
<li>老年代（养老区）：被长时间使用的对象，老年代的内存空间应该要比年轻代更大</li>
<li>元空间（JDK1.8 之前叫永久代）：像一些方法中的操作临时对象等，JDK1.8 之前是占用 JVM 内存，JDK1.8 之后直接使用物理内存</li>
</ul>
<p>Java 虚拟机规范规定，Java 堆可以是处于物理上不连续的内存空间中，只要逻辑上是连续的即可，像磁盘空间一样。实现时，既可以是固定大小，也可以是可扩展的，主流虚拟机都是可扩展的（通过 <code>-Xmx</code> 和 <code>-Xms</code> 控制）。</p>
<p><strong>为什么堆区会引起线程安全的问题？用什么方法去避免这些问题</strong> </p>
<p>堆是所有线程共享的一片公用内存区域。对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己 的栈，如果多个线程使用该变量就可能引发问题，这时volatile 变量就可以发挥作用了，它要求线程从主存中读取变量的值。</p>
<p><strong>年轻代 (Young Generation)</strong></p>
<p>年轻代是所有新对象创建的地方。当填充年轻代时，执行垃圾收集。这种垃圾收集称为 <strong>Minor GC</strong>。年轻一代被分为三个部分——伊甸园（<strong>Eden Memory</strong>）和两个幸存区（<strong>Survivor Memory</strong>，被称为from/to或s0/s1），默认比例是<code>8:1:1</code></p>
<ul>
<li>大多数新创建的对象都位于 Eden 内存空间中</li>
<li>当 Eden 空间被对象填充时，执行<strong>Minor GC</strong>，并将所有幸存者对象移动到一个幸存者空间中</li>
<li>Minor GC 检查幸存者对象，并将它们移动到另一个幸存者空间。所以每次，一个幸存者空间总是空的</li>
<li>经过多次 GC 循环后存活下来的对象被移动到老年代。通常，这是通过设置年轻一代对象的年龄阈值来实现的，然后他们才有资格提升到老一代</li>
</ul>
<p><strong>老年代(Old Generation)</strong></p>
<p>旧的一代内存包含那些经过许多轮小型 GC 后仍然存活的对象。通常，垃圾收集是在老年代内存满时执行的。老年代垃圾收集称为 主GC（Major GC），通常需要更长的时间。</p>
<p>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在 Eden 区和两个Survivor 区之间发生大量的内存拷贝</p>
<p><img src="E:\Document\学习笔记\图片\JVM虚拟机\generation.jpg" alt="img"></p>
<p><strong>元空间</strong></p>
<p>不管是 JDK8 之前的永久代，还是 JDK8 及以后的元空间，都可以看作是 Java 虚拟机规范中方法区的实现。</p>
<p>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap（非堆），目的应该是与 Java 堆区分开。</p>
<p>所以元空间放在后边的方法区再说。</p>
<p><strong>对象在堆中的生命周期</strong></p>
<ol>
<li>在 JVM 内存模型的堆中，堆被划分为新生代和老年代<ul>
<li>新生代又被进一步划分为 <strong>Eden区</strong> 和 <strong>Survivor区</strong>，Survivor 区由 <strong>From Survivor</strong> 和 <strong>To Survivor</strong> 组成</li>
</ul>
</li>
<li>当创建一个对象时，对象会被优先分配到新生代的 Eden 区<ul>
<li>此时 JVM 会给对象定义一个<strong>对象年轻计数器</strong>（<code>-XX:MaxTenuringThreshold</code>）</li>
</ul>
</li>
<li>当 Eden 空间不足时，JVM 将执行新生代的垃圾回收（Minor GC）<ul>
<li>JVM 会把存活的对象转移到 Survivor 中，并且对象年龄 +1</li>
<li>对象在 Survivor 中同样也会经历 Minor GC，每经历一次 Minor GC，对象年龄都会+1</li>
</ul>
</li>
<li>如果分配的对象超过了<code>-XX:PetenureSizeThreshold</code>，对象会<strong>直接被分配到老年代</strong> </li>
</ol>
<p><strong>对象的分配过程</strong></p>
<p>为对象分配内存是一件非常严谨和复杂的任务，JVM 的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法和内存回收算法密切相关，所以还需要考虑 GC 执行完内存回收后是否会在内存空间中产生内存碎片。</p>
<ol>
<li>new 的对象先放在伊甸园区，此区有大小限制</li>
<li>当伊甸园的空间填满时，程序又需要创建对象，JVM 的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</li>
<li>然后将伊甸园中的剩余对象移动到幸存者 0 区</li>
<li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者 0 区，如果没有回收，就会放到幸存者 1 区</li>
<li>如果再次经历垃圾回收，此时会重新放回幸存者 0 区，接着再去幸存者 1 区</li>
<li>什么时候才会去养老区呢？ 默认是 15 次回收标记</li>
<li>在养老区，相对悠闲。当养老区内存不足时，再次触发 Major GC，进行养老区的内存清理</li>
<li>若养老区执行了 Major GC  之后发现依然无法进行对象的保存，就会产生 OOM 异常</li>
</ol>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><ul>
<li>方法区（Method Area）与 Java 堆一样，是所有<strong>线程共享</strong>的内存区域。</li>
<li>用于加载已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</li>
<li>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap（非堆），目的应该是与 Java 堆区分开。</li>
<li>方法区的大小和堆空间一样，可以选择固定大小也可选择可扩展，方法区的大小决定了系统可以放多少个类，如果系统类太多，导致方法区溢出，虚拟机同样会抛出内存溢出错误</li>
<li>JVM 关闭后方法区即被释放</li>
<li>该区域的回收目标主要是针对常量池的回收和对类型的卸载。</li>
</ul>
<p><strong>为什么去永久代？讲下内存泄漏的一些原因</strong></p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a><strong>运行时常量池</strong></h3><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。</p>
<p>Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是<strong>常量池表</strong>（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p>
<p>运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的是 <code>String.intern()</code>方法。受方法区内存的限制，当常量池无法再申请到内存时会抛出 <code>OutOfMemoryErro</code>r 异常。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存（Direct Memory）不是虚拟机运行时数据区的一部分。</p>
<h1 id="HotSpot-虚拟机中的对象"><a href="#HotSpot-虚拟机中的对象" class="headerlink" title="HotSpot 虚拟机中的对象"></a>HotSpot 虚拟机中的对象</h1><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p><strong>1. 类加载检查过程</strong></p>
<p>Java 虚拟机遇到一条 new 指令，检查这个指令的参数是否能在常量池中定位到一个类的符号引用。</p>
<ul>
<li><p>如果能定位到，检查这个符号引用代表的类是否已被加载、解析和初始化过；</p>
</li>
<li><p>如果没有检查到，就必须先执行相应的类加载过程；</p>
</li>
</ul>
<p><strong>2. 分配内存</strong></p>
<p>对象所需内存的大小在类加载完成后便完全确定（Java虚拟机可以通过普通Java对象的类元数据信息确定对象大小）</p>
<p>为对象分配内存相当于把一块确定大小的内存从Java堆里划分出来；</p>
<p><strong>3.初始化为零值，必要的设置</strong></p>
<p>对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码对象的GC分代年龄等信息。这些信息存放在对象的对象头中。</p>
<p><strong>4.构造函数</strong></p>
<p>执行Class文件中的<code>&lt;init&gt;()</code>方法，按照程序员的意愿对对象进行初始化。</p>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>对象头</p>
<p>实例数据</p>
<p>对齐填充</p>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>使用句柄</p>
<p>直接访问</p>
<h1 id="垃圾收集（Garbage-Collection，GC）"><a href="#垃圾收集（Garbage-Collection，GC）" class="headerlink" title="垃圾收集（Garbage Collection，GC）"></a>垃圾收集（Garbage Collection，GC）</h1><p>垃圾回收：释放垃圾占用的空间</p>
<p>当一个对象不再被需要时，该对象就需要被回收并释放空间</p>
<p>Java内存运行时数据区域</p>
<ul>
<li>程序计数器，线程私有</li>
<li>虚拟机栈，线程私有</li>
<li>本地方法栈，线程私有</li>
<li>堆</li>
</ul>
<h2 id="判断对象是否可回收"><a href="#判断对象是否可回收" class="headerlink" title="判断对象是否可回收"></a><strong>判断对象是否可回收</strong></h2><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>给每个对象添加引用计数器，为0即为可回收的对象</p>
<h3 id="根搜索算法（主流商用语言使用）"><a href="#根搜索算法（主流商用语言使用）" class="headerlink" title="根搜索算法（主流商用语言使用）"></a>根搜索算法（主流商用语言使用）</h3><p>从若干被称为GC Roots 的对象开始进行搜索，不能到达的对象即为可回收的对象</p>
<p>Java中，GC Roots一般包含下面几种对象：</p>
<ul>
<li><p>虚拟机中引用的对象</p>
</li>
<li><p>本地方法栈中的本地方法引用的对象</p>
</li>
<li><p>方法区中的类静态属性引用的对象</p>
</li>
<li><p>方法区中的常量引用的对象</p>
</li>
<li><p>引用的分类</p>
<ul>
<li>强引用 代码中普遍存在的引用  垃圾回收器不会回收被强引用关联的对象</li>
<li>软引用 有用但非必须的对象 系统将要发生内存溢出异常时，回收 <code>SoftReference</code>类</li>
<li>弱引用 非必须的对象 被弱引用关联的对象只能存活到下一次垃圾回收之前，当垃圾回收器工作时，被弱引用关联的对象一定会被回收 WeakReference</li>
<li>虚引用 最弱  一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，唯一目的就是能在这个对象被回收时收到一个系统通知。PhantomReference</li>
</ul>
</li>
</ul>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a><strong>垃圾收集算法</strong></h2><h3 id="引用计数式垃圾收集"><a href="#引用计数式垃圾收集" class="headerlink" title="引用计数式垃圾收集"></a>引用计数式垃圾收集</h3><p>（Reference Counting GC，直接垃圾收集）</p>
<h3 id="追踪式垃圾收集"><a href="#追踪式垃圾收集" class="headerlink" title="追踪式垃圾收集"></a>追踪式垃圾收集</h3><p>（Tracing GC，间接垃圾收集）</p>
<h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>算法分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象</p>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这块内存需要进行垃圾回收时，会将此区域还存活着的对象复制到另一块上面，然后再把已经使用过的内存区域一次清理掉。</p>
<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>复制收集算法在对象存活率较高时会进行比较多的复制操作，效率会变低。因此在老年代一般不能使用复制算法。</p>
<p>针对老年代的特点，提出了一种称之为“标记-整理算法”。</p>
<p>标记过程仍与“标记-清除”过程一致，但后续步骤不是直接对可回收对象进行清理，而是让所有存活对象向一端移动，然后直接清理掉端边界以外的内存。</p>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>根据对象存活周期的不同将内存划分为几块。</p>
<p> 一般是把Java堆分为新生代和老年代。</p>
<p>在新生代中，每次垃圾回收都有大批对象死去，只有少量存活，因此我们采用复制算法；</p>
<p>而老年代中对象存活率高、没有额外空间对它进行分配担保，就必须采用”标记-清理”或者”标记-整理”算法。</p>
<p><strong>分代收集理论</strong></p>
<h2 id="Minor-GC和Full-GC的区别："><a href="#Minor-GC和Full-GC的区别：" class="headerlink" title="Minor GC和Full GC的区别："></a>Minor GC和Full GC的区别：</h2><ul>
<li>Minor GC（新生代GC）：指的是发生在新生代的垃圾收集。因为Java对象大多都具备朝生夕灭的特性，因此Minor GC（采用复制算法）非常频繁，一般回收速度也比较快。</li>
<li>Full GC（老年代GC，Major GC）：指发生在老年代的垃圾收集。出现了Major GC，经常会伴随至少一次的Minor GC（并非绝对，在Parallel Scavenge收集器中就有直接进行Full GC的策略选择过程</li>
</ul>
<h2 id="调用垃圾回收器的方法"><a href="#调用垃圾回收器的方法" class="headerlink" title="调用垃圾回收器的方法"></a><strong>调用垃圾回收器的方法</strong></h2><p>调用垃圾回收的方法是gc</p>
<p>java.lang.System.gc 等价于 java.lang.Runtime.getRuntime.gc 的简写</p>
<p>在 Runtime 中 gc 是实例方法</p>
<p>在 System 中 gc 是静态方法，该方法调用Runtime类中的gc方法</p>
<h2 id="finalize方法"><a href="#finalize方法" class="headerlink" title="finalize方法"></a><strong>finalize方法</strong></h2><p>在Object类中定义，释放对象占用的内存之前调用</p>
<p>默认不做任何实现</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>新生代收集器：Serail、ParNew、Parallel Sacvenge</p>
<p>老年代收集器：Serail Old、CMS、Parallel Old</p>
<p>面向堆内存任何部分来组成回收集（并不是面向整个堆Full GC）：Garbage First</p>
<h3 id="经典垃圾收集器"><a href="#经典垃圾收集器" class="headerlink" title="经典垃圾收集器"></a>经典垃圾收集器</h3><h4 id="Serial-垃圾收集器"><a href="#Serial-垃圾收集器" class="headerlink" title="Serial 垃圾收集器"></a><strong>Serial 垃圾收集器</strong></h4><p>是基础的，历史最悠久的收集器</p>
<p>单线程工作的收集器</p>
<p>在它进行垃圾收集时，必须暂停其他所有工作线程，直至它收集结束。“ Stop The World ”</p>
<p>HotSpot 虚拟机在客户端模式下的默认新生代收集器。</p>
<p>优势：简单而高效。额外内存消耗最小。</p>
<h4 id="ParNew-垃圾收集器"><a href="#ParNew-垃圾收集器" class="headerlink" title="ParNew 垃圾收集器"></a><strong>ParNew 垃圾收集器</strong></h4><p>Serail收集器的多线程并行版本</p>
<p>除了Serail收集器外，目前只有它能与CMS收集器配合工作。</p>
<p>是激活CMS后的默认新生代收集器</p>
<p>-XX:+/UseParNewGC</p>
<p>默认开启的收集线程数与处理器核心数量相同。</p>
<h4 id="Parallel-Seavenge-收集器"><a href="#Parallel-Seavenge-收集器" class="headerlink" title="Parallel Seavenge 收集器"></a><strong>Parallel Seavenge 收集器</strong></h4><p>新生代收集器，基于标记-复制算法实现，并行收集的多线程收集器。</p>
<p>特点：目标是达到一个可控制的吞吐量。</p>
<p>被称作 “ 吞吐量优先收集器 ”。</p>
<h4 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a><strong>Serial Old 收集器</strong></h4><p>Serail 收集器的老年代版本，单线程收集器，使用标记-整理算法。</p>
<h4 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a><strong>Parallel Old 收集器</strong></h4><p>Parallel Seavenge收集器的老年版本，支持多线程并发收集，基于标记-整理算法。</p>
<h4 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a><strong>CMS 收集器</strong></h4><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短挥手停顿时间为目标的收集器，基于<strong>标记-清除</strong>算法。（sweep：打扫，清扫），目前很大一部分的 Java 应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的相应速度。</p>
<p>整个过程分为四个步骤：</p>
<ol>
<li><p><strong>初始标记</strong>（CMS initial mark）</p>
<p>仅标记以下GC Roots能直接关联到的对象，速度很快。</p>
</li>
<li><p><strong>并发标记</strong>（CMS concurrent mark）</p>
<p>从GC Roots的直接关联对象开始遍历整个对象图的过程，耗时较长但不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</p>
</li>
<li><p><strong>重新标记</strong>（CMS remark）</p>
<p>修正并发标记期间因用户程序继续运作而导致标记产生表动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</p>
</li>
<li><p><strong>并发清除</strong>（CMS concurrent sweep）</p>
<p>清理删除掉标记阶段判断的已经死亡的对象</p>
<p>由于不需要移动存活对象，这个阶段也是可以与用户线程同时并发的。</p>
</li>
</ol>
<p>三个明显的<strong>缺点</strong>：</p>
<ol>
<li><p>对处理器资源非常敏感，在并发阶段，它虽然不会导致用户线程停顿，但会因为占用了一部分线程（或者说处理器的计算能力）而导致应用程序变慢，降低吞吐量。</p>
<p>CMS 默认启动的回收线程数是（处理器核心数量+3）/ 4。处理器核心数量不足四个时，影响会变得很大。</p>
</li>
<li><p>无法处理 “ 浮动垃圾 ”，可能会出现 “Concurrent Mode Failure（并发模式故障）” 失败而导致另一次完全 “ Stop The Word” 的 Full GC 产生。</p>
</li>
<li><p>收集结束时会有大量空间碎片产生。</p>
<p>CMS是一款“标记–清除”算法实现的收集器，容易出现大量空间碎片。</p>
<p>当空间碎片过多，将会给大对象分配带来很大的麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。</p>
</li>
</ol>
<h4 id="Garbage-First-收集器（G1）"><a href="#Garbage-First-收集器（G1）" class="headerlink" title="Garbage First 收集器（G1）"></a><strong>Garbage First 收集器（G1）</strong></h4><p>G1是一款面向服务端应用的垃圾收集器。它开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。</p>
<p>从 JDK9 开始成为服务段模式下的默认垃圾收集器。</p>
<p><strong>停顿时间模型</strong>（Pause Prediction Model）：在一个长度位M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒。</p>
<p><strong>Mixed GC模式：</strong>可以面向堆内存任何部分来组成回收集（Collection Set，一般简称CSet）进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器<strong>Mixed GC模式</strong>。</p>
<p><strong>基于Region的堆内存布局：</strong></p>
<p>G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。</p>
<p><strong>Humongous区域：</strong></p>
<p>Region中的一类特殊区域，专门用来存储大对象。</p>
<p>G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。</p>
<p>对于超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中。</p>
<p>G1中的大多数行为都把Humongous Region作为老年代的一部分看待。</p>
<p><strong>价值：</strong></p>
<p>价值即回收所获得的空间大小以及回收所需时间的经验值</p>
<p>G1收集器跟踪各个Region里面的垃圾堆积的<strong>价值</strong>大小，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间优先处理回收价值最大的那些Region。（收集停顿时间可使用参数<code>XX:MaxGCPauseMillis</code>指定，默认值是200毫秒）。</p>
<p><strong>G1收集器的运作过程：</strong></p>
<p>G1收集器的运作过程大致可划分为以下四个步骤：</p>
<ol>
<li><strong>初始标记</strong>（Initial Marking）： 仅仅是标记一些GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的 Region 中分配新的对象。</li>
<li><strong>并发标记</strong>（Concurrent Marking）： 从GC Roots开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象。耗时较长，但可与用户线程并发执行。</li>
<li><strong>最终标记</strong>（Final Marking）： 对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。</li>
<li><strong>筛选回收</strong>（Live Data Counting and Evacuation）： 负责更新Region的统计数量，对各个Region进行回收价值和成本排序，根据用户期望的停顿时间制定回收计划，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧的Region的全部空间。</li>
</ol>
<p><strong>G1收集器解决的关键细节问题：</strong>、</p>
<ul>
<li><strong>Region里面的跨Region引用对象如何解决？</strong></li>
<li><strong>在并发标记阶段如何保证收集线程与用户线程互不干扰的运行？</strong></li>
<li><strong>怎样建立起可靠的停顿模型？</strong></li>
</ul>
<h4 id="G1与CMS的比较"><a href="#G1与CMS的比较" class="headerlink" title="G1与CMS的比较"></a>G1与CMS的比较</h4><p>G1的优点：</p>
<ul>
<li><p>可以指定最大停顿时间</p>
</li>
<li><p>分Region的内存布局</p>
</li>
<li><p>按收益动态确定回收集</p>
</li>
<li><p>CMS采用 “ 标记-清除算法 ”，G1从整体上看是基于 “ 标记-整理算法 ”，从局部（两个Region之间）上看又是基于 “ 标记-复制 ” 算法的。这两种算法意味着G1运作期间<strong>不会产生内存空间碎片</strong>，垃圾收集完成后能提供完整的可用内存。这种特性有利于程序长时间运行，在程序为大对象分配内存时不容易因无法找到连续内存空间而提前触发下一次收集。</p>
</li>
</ul>
<p>G1的弱项：</p>
<ul>
<li>在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footpring）还是程序运行时的额外负载（Overload）都要比CMS高。</li>
<li>G1的卡表实现更为复杂</li>
<li>G1对写屏障的复杂操作要比CMS消耗更多的运算资源。</li>
</ul>
<p><strong>CMS和G1应用场景：</strong></p>
<p>小内存应用上CMS的表现大概率仍然由于G1</p>
<p>大内存应用上G1大多能发挥其优势</p>
<p>这个Java堆容量平衡点通常在6GB至8GB之间。</p>
<h3 id="低延迟垃圾收集器"><a href="#低延迟垃圾收集器" class="headerlink" title="低延迟垃圾收集器"></a>低延迟垃圾收集器</h3><p>Shenandoah 收集器</p>
<p>ZGC收集器</p>
<h3 id="垃圾收集器的选择"><a href="#垃圾收集器的选择" class="headerlink" title="垃圾收集器的选择"></a>垃圾收集器的选择</h3><h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p>其中类加载的过程包括了<strong>加载、验证、准备、解析、初始化</strong>五个阶段</p>
<p>在这五个阶段中，加载、验证、准备、和初始化这四个阶段发生的顺序是确定的，而<strong>解析</strong>阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定(也称为动态绑定或晚期绑定)。</p>
<p><img src="E:\Document\学习笔记\图片\JVM虚拟机\java_jvm_classload_2.png" alt="img"></p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情:</p>
<ul>
<li><p>通过一个类的全限定名来获取其定义的二进制字节流。</p>
</li>
<li><p>将这个字节流所代表的静态存储结构转化为<strong>方法区</strong>的运行时数据结构。</p>
</li>
<li><p>在Java<strong>堆</strong>中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</p>
</li>
</ul>
<p><img src="E:\Document\学习笔记\图片\JVM虚拟机\java_jvm_classload_1.png" alt="img"></p>
<p>相对于类加载的其他阶段而言，加载阶段(准确地说，是加载阶段获取类的二进制字节流的动作)是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p>
<p>类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误(LinkageError错误)如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p>
<p><strong>加载.class文件的方式</strong></p>
<ul>
<li>从本地系统中直接加载</li>
<li>通过网络下载.class文件</li>
<li>从zip，jar等归档文件中加载.class文件</li>
<li>从专有数据库中提取.class文件</li>
<li>将Java源文件动态编译为.class文件</li>
</ul>
<h3 id="连接（验证，准备，解析）"><a href="#连接（验证，准备，解析）" class="headerlink" title="连接（验证，准备，解析）"></a>连接（验证，准备，解析）</h3><p><strong>验证</strong></p>
<p>验证是连接阶段的第一步，目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用<code>-Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<p>该阶段大致会完成4个阶段的检验动作:</p>
<ul>
<li>文件格式验证: 验证字节流是否符合Class文件格式的规范；例如: 是否以<code>0xCAFEBABE</code>开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li>
<li>元数据验证: 对字节码描述的信息进行语义分析(注意: 对比<code>javac</code>编译阶段的语义分析)，以保证其描述的信息符合Java语言规范的要求；例如: 这个类是否有父类，除了<code>java.lang.Object</code>之外。</li>
<li>字节码验证: 通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li>
<li>符号引用验证: 确保解析动作能正确执行。</li>
</ul>
<p><strong>准备</strong></p>
<p>该阶段为正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在<strong>方法区</strong>中分配。</p>
<p>这时候进行内存分配的仅包括类变量(<code>static</code>)，而<strong>不包括实例变量</strong>，实例变量会在对象实例化时随着对象一块分配在Java堆中。</p>
<p>这里所设置的初始值通常情况下是数据类型默认的零值(如<code>0</code>、<code>0L</code>、<code>null</code>、<code>false</code>等)，而不是被在Java代码中被显式地赋予的值。</p>
<p>假设一个类变量的定义为: <code>public static int value = 3</code>；那么变量value在准备阶段过后的初始值为<code>0</code>，而不是<code>3</code>，因为这时候尚未开始执行任何Java方法，而把value赋值为3的<code>put static</code>指令是在程序编译后，存放于类构造器<code>&lt;clinit&gt;()</code>方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。</p>
<ul>
<li>对基本数据类型来说，对于类变量(static)和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</li>
<li>对于同时被<code>static</code>和<code>final</code>修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</li>
<li>对于引用数据类型<code>reference</code>来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即<code>null</code>。</li>
<li>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</li>
<li>如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。假设上面的类变量value被定义为: <code>public static final int value = 3；</code>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。我们可以理解为<code>static final</code>常量在编译期就将其结果放入了调用它的类的常量池中</li>
</ul>
<p><strong>解析</strong></p>
<p>是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<p>解析动作主要针对<code>类</code>或<code>接口</code>、<code>字段</code>、<code>类方法</code>、<code>接口方法</code>、<code>方法类型</code>、<code>方法句柄</code>和<code>调用点</code>限定符7类符号引用进行。</p>
<p>符号引用就是一组符号来描述目标，可以是任何字面量，直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式:</p>
<ul>
<li>声明类变量时指定初始值</li>
<li>使用静态代码块为类变量指定初始值</li>
</ul>
<p><strong>JVM初始化步骤</strong></p>
<ul>
<li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li>
<li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li>
<li>假如类中有初始化语句，则系统依次执行这些初始化语句</li>
</ul>
<p><strong>类初始化时机</strong>: 只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种:</p>
<ul>
<li>创建类的实例，也就是new的方式</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射(如Class.forName(“com.pdai.jvm.Test”))</li>
<li>初始化某个类的子类，则其父类也会被初始化</li>
<li>Java虚拟机启动时被标明为启动类的类(Java Test)，直接使用java.exe命令来运行某个主类</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>类访问方法区内的数据结构的接口， 对象是堆(Heap)区的数据。</p>
<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p><strong>Java虚拟机将结束生命周期的几种情况</strong></p>
<ul>
<li>执行了System.exit()方法</li>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止</li>
<li>由于操作系统出现错误而导致Java虚拟机进程终止</li>
</ul>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p><strong>类加载器的层次</strong></p>
<p><img src="E:\Document\学习笔记\图片\JVM虚拟机\java_jvm_classload_3.png" alt="img"></p>
<p>注意: 这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的。</p>
<p><strong>类加载器分类</strong></p>
<p>站在Java虚拟机的角度来讲，只存在两种不同的类加载器: </p>
<ul>
<li>启动类加载器: 它使用C++实现(这里仅限于<code>Hotspot</code>，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的)，是虚拟机自身的一部分。</li>
<li>所有其他的类加载器: 这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类<code>java.lang.ClassLoader</code>，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</li>
</ul>
<p>站在Java开发人员的角度来看，类加载器可以大致划分为以下三类 :</p>
<ul>
<li>启动类加载器: Bootstrap ClassLoader，负责加载存放在 ”JDK\jre\lib“ (JDK代表JDK的安装目录)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库(如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载)。启动类加载器是无法被Java程序直接引用的。</li>
<li>扩展类加载器: Extension ClassLoader，该加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库(如javax.*开头的类)，开发者可以直接使用扩展类加载器。</li>
<li>应用程序类加载器: Application ClassLoader，该类加载器由<code>sun.misc.Launcher$AppClassLoader</code>来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ul>
<p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点:</p>
<ul>
<li>在执行非置信代码之前，自动验证数字签名。</li>
<li>动态地创建符合用户特定需要的定制化构建类。</li>
<li>从特定的场所取得java class，例如数据库中和网络中。</li>
</ul>
<p><strong>寻找类加载器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pdai.jvm.classloader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassLoader loader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        System.out.println(loader);</span><br><span class="line">        System.out.println(loader.getParent());</span><br><span class="line">        System.out.println(loader.getParent().getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@64fef26a</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@1ddd40f3</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<p>从上面的结果可以看出，并没有获取到<code>ExtClassLoader</code>的父Loader，原因是<code>BootstrapLoader</code>(引导类加载器)是用C语言实现的，找不到一个确定的返回父Loader的方式，于是就返回<code>null</code>。</p>
<p><strong>类加载的方式</strong></p>
<ul>
<li><p>命令行启动应用时候由JVM初始化加载</p>
</li>
<li><p>通过Class.forName()方法动态加载</p>
</li>
<li><p>通过ClassLoader.loadClass()方法动态加载</p>
</li>
</ul>
<p><strong>Class.forName()和ClassLoader.loadClass()区别?</strong></p>
<ul>
<li>Class.forName(): 将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</li>
<li>ClassLoader.loadClass(): 只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</li>
<li>Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。</li>
</ul>
<p><strong>自定义类加载器</strong></p>
<h2 id="JVM类加载机制"><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h2><p><strong>全盘负责</strong></p>
<p>当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显式使用另外一个类加载器来载入。</p>
<p><strong>父类委托</strong></p>
<p>先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。</p>
<p><strong>缓存机制</strong></p>
<p>缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效。</p>
<p><strong>双亲委派机制</strong></p>
<p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到<strong>顶层的启动类加载器</strong>中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p>
<ol>
<li>当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。 </li>
<li>当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。 </li>
<li>如果BootStrapClassLoader加载失败(例如在$JAVA_HOME/jre/lib里未查找到该class)，会使用ExtClassLoader来尝试加载。</li>
<li>若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。</li>
</ol>
<p><strong>双亲委派优势</strong></p>
<ul>
<li>Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系。通过这种层级关系可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。</li>
<li>保证Java程序安全稳定运行。Java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。</li>
</ul>
<p><strong>能不能自己写个类叫java.lang.System？</strong></p>
<blockquote>
<p>答案：通常不可以，但可以采取另类方法达到这个需求。<br>解释：为了不让我们写System类，类加载采用委托机制，这样可以保证爸爸们优先，爸爸们能找到的类，儿子就没有机会加载。而System类是Bootstrap加载器加载的，就算自己重写，也总是使用Java系统提供的System，自己写的System类根本没有机会得到加载。</p>
<p>但是，我们可以自己定义一个类加载器来达到这个目的，为了避免双亲委托机制，这个类加载器也必须是特殊的。由于系统自带的三个类加载器都加载特定目录下的类，如果我们自己的类加载器放在一个特殊的目录，那么系统的加载器就无法加载，也就是最终还是由我们自己的加载器加载。</p>
</blockquote>
<p><strong>关于双亲委派引申的一些框架</strong></p>
<p>Tomcat</p>
<h1 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h1><ul>
<li>Major GC的速度一般会比Minor GC慢10倍以上。</li>
</ul>
<h1 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h1><p>逃逸分析是Java虚拟机中的一种编译器优化技术，不直接优化代码。</p>
<p><strong>基本原理：</strong></p>
<p>分析对象的动态作用域</p>
<p>当一个对象在方法里被定义后，它可能被外部方法所引用，例如作为参数传递到其他方法中，这种称为<strong>方法逃逸</strong>；</p>
<p>甚至还有可能被外部线程访问到，譬如赋值给其他线程中访问到的实例变量，这种称为<strong>线程逃逸</strong>；</p>
<p><strong>优化：</strong></p>
<ul>
<li><p><strong>栈上分配：</strong></p>
<p>如果确定一个对象不会逃逸出线程之外，那可以让这个对象在栈上分配内存，对象所占用的内存空间可以随栈帧出栈而销毁。</p>
<p>栈上分配支持方法逃逸，不支持线程逃逸。</p>
</li>
<li><p><strong>标量替换：</strong></p>
<p>若一个数据已无法再分解成更小的数据来表示了，那么这些数据就可以称为<strong>标量</strong>，如Java虚拟机中原始数据类型（int，long等数值类型及reference类型）。</p>
<p>如果一个数据可以继续分解，那它就被称为<strong>聚合量</strong>。</p>
<p>如果一个数据可以把一个Java对象拆散，根据程序访问的情况，将其用到的成员变量恢复为原始类型来访问，这个过程就称为<strong>标量替换</strong>。</p>
<p>假如逃逸分析能够证明一个对象不会被方法外部访问，并且这个对象可以被拆散，那么程序执行时可能不去创建这个对象，而改为直接创建它的若干个被这个方法使用的成员变量来代替，让对象的成员变量在栈上分配和读写。</p>
<p><strong>标量替换可以视作栈上分配的一种特例</strong></p>
<p>标量替换不允许对象逃逸出方法范围内。</p>
</li>
<li><p><strong>同步消除：</strong></p>
<p>如果同步逃逸分析能够确定一个变量不会逃逸出线程，即无法被其他线程访问，那么这个变量的读写就不会有竞争，对这个变量实施的同步措施也就可以安全地消除掉。</p>
</li>
</ul>
<h1 id="即时编译器"><a href="#即时编译器" class="headerlink" title="即时编译器"></a>即时编译器</h1><p>目前主流的两款商用Java虚拟机（HotSpot、OpenJ9）里，Java程序最初都是通过<strong>解释器</strong>进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁，就会把这些代码认定为 “ <strong>热点代码</strong> ”，为了提高热点代码的执行效率，在运行时，虚拟机就会把这些代码编译成本地机器码，并以各种手段尽可能地进行代码优化，运行完成这个任务的后端编译器被称为<strong>即时编译器</strong>。</p>
<h1 id="Java虚拟机的启动"><a href="#Java虚拟机的启动" class="headerlink" title="Java虚拟机的启动"></a>Java虚拟机的启动</h1><p>操作系统装入 JVM，是通过jdk中Java.exe来完成的</p>
<p>1.创建 JVM 装载环境和配置</p>
<p>2.装载 JVM.dll</p>
<p>3.初始化 JVM.dll并挂界到 JNIENV（JNI调用接口）实例</p>
<p>4.调用 JNIEnv 实例装载并处理class类。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/25/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-id="ckp3gdqh60001poup8t200aho" data-title="JVM学习笔记" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/06/20/%E7%BB%9F%E8%AE%A1%E5%BB%BA%E6%A8%A1%EF%BC%9A%E5%88%86%E7%B1%BB%E6%80%A7%E8%83%BD%E8%AF%84%E4%BB%B7%EF%BC%88%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5%E5%92%8CROC%E6%9B%B2%E7%BA%BF%EF%BC%89/">统计建模：分类性能评价（混淆矩阵和ROC曲线）</a>
          </li>
        
          <li>
            <a href="/2021/06/20/%E7%BB%9F%E8%AE%A1%E5%BB%BA%E6%A8%A1%EF%BC%9A%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A8%A1%E5%9E%8B/">统计建模：朴素贝叶斯模型</a>
          </li>
        
          <li>
            <a href="/2021/06/20/%E7%BB%9F%E8%AE%A1%E5%BB%BA%E6%A8%A1%EF%BC%9ALogistic%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B%EF%BC%88%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%EF%BC%89/">统计建模：Logistic回归模型（逻辑回归）</a>
          </li>
        
          <li>
            <a href="/2021/06/20/%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1%EF%BC%9A%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E6%A6%82%E8%BF%B0/">数据建模：统计分析概述</a>
          </li>
        
          <li>
            <a href="/2021/05/25/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Spring学习笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 王云涛<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>