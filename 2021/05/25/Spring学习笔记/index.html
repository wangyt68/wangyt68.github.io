<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Spring学习笔记 | 我的学习笔记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="SpringSpring 用于解决企业级框架的复杂性，适用于任何 java 应用 Spring是一个轻量级控制反转(IoC)和面向切面(AOP)的容器框架。 发展历史2002, 首次推出Spring框架的雏形 interface 212004年3月24日, 以interface 21 为基础，经过重新设计正式发布Spring1.0版本Rod Johnson Spring Framework创始人，">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring学习笔记">
<meta property="og:url" content="http://example.com/2021/05/25/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="我的学习笔记">
<meta property="og:description" content="SpringSpring 用于解决企业级框架的复杂性，适用于任何 java 应用 Spring是一个轻量级控制反转(IoC)和面向切面(AOP)的容器框架。 发展历史2002, 首次推出Spring框架的雏形 interface 212004年3月24日, 以interface 21 为基础，经过重新设计正式发布Spring1.0版本Rod Johnson Spring Framework创始人，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="e:/Document/学习笔记/图片/aop.png">
<meta property="og:image" content="http://example.com/2021/05/25/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5.Spring.assets/SpringAOPProcess.jpg">
<meta property="og:image" content="http://example.com/2021/05/25/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5.Spring.assets/2020070215205383.png">
<meta property="og:image" content="http://example.com/2021/05/25/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/.%5C%E5%9B%BE%E7%89%87%5CSpring%5Cshiro-1.png">
<meta property="og:image" content="https://atts.w3cschool.cn/attachments/image/wk/shiro/2.png">
<meta property="article:published_time" content="2021-05-25T03:02:01.000Z">
<meta property="article:modified_time" content="2021-05-25T03:02:19.130Z">
<meta property="article:author" content="王云涛">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="e:/Document/学习笔记/图片/aop.png">
  
    <link rel="alternate" href="/atom.xml" title="我的学习笔记" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">我的学习笔记</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Spring学习笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/25/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2021-05-25T03:02:01.000Z" itemprop="datePublished">2021-05-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Spring学习笔记
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p>Spring 用于解决企业级框架的复杂性，适用于任何 java 应用</p>
<p>Spring是一个轻量级控制反转(IoC)和面向切面(AOP)的容器框架。</p>
<h2 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h2><p>2002, 首次推出Spring框架的雏形 interface 21<br>2004年3月24日, 以interface 21 为基础，经过重新设计正式发布Spring1.0版本<br>Rod Johnson Spring Framework创始人，音乐学博士</p>
<h2 id="Spring-理念"><a href="#Spring-理念" class="headerlink" title="Spring 理念"></a>Spring 理念</h2><ul>
<li><p>强大的向后兼容性 </p>
</li>
<li><p>代码标准质量高</p>
</li>
<li><p>使现有的技术更加容易使用，本身是一个大杂烩，整合了现有的技术框架。<br>SSH: Struct2 + Spring + Hibernate<br>SSM: SpringMVC + Spring + Mybatis</p>
</li>
</ul>
<p>官网: <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/overview.html#overview">https://docs.spring.io/spring-framework/docs/current/reference/html/overview.html#overview</a><br>官方下载地址<a target="_blank" rel="noopener" href="https://repo.spring.io/release/org/springframework/spring/">https://repo.spring.io/release/org/springframework/spring/</a><br>github: <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework">https://github.com/spring-projects/spring-framework</a></p>
<p><strong>优点</strong>：开源 免费 轻量级 非入侵式 控制反转(IOC) 面向切面编程（AOP） 支持事务的处理 对框架整合的支持</p>
<p><strong>组成</strong>：七模块 AOP ORM Context …</p>
<p>Spring发展太久后违背了原来的理念，配置十分繁琐。</p>
<p>SpringBoot旨在使用最小的配置启动应用</p>
<p>Spring Boot: 一个快速开发的脚手架，基于SpringBoot 可以快速的开发单个微服务，约定大于配置。</p>
<p>Spring Cloud: 是基于SpringBoot实现的</p>
<h2 id="Spring-的整体架构"><a href="#Spring-的整体架构" class="headerlink" title="Spring 的整体架构"></a>Spring 的整体架构</h2><p>Spring 是一个分层架构，包含一系列的功能要素，并被分为大约20个模块。</p>
<p>这些模块被总结为以下几部分：</p>
<ul>
<li>Core Container（核心容器）：包含有Core、Beans、Context和Expression Language模块。</li>
<li>Data Access/Integration：包含JDBC、ORM、OXM、JMS 和 Transaction模块。</li>
<li>Web：Web上下文模块建立在应用程序上下文模块之上，为基于Web的应用程序提供了上下文。包含Web、Web-Servlet、Web-Porlet模块。</li>
<li>AOP</li>
<li>Test</li>
</ul>
<h2 id="控制反转（IoC）"><a href="#控制反转（IoC）" class="headerlink" title="控制反转（IoC）"></a>控制反转（IoC）</h2><p>IoC（Inversion of Control，控制反转）是一种设计思想，而依赖注入（DI）是IOC的一种实现方式。</p>
<p>在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。</p>
<p>Spring 中实现IOC的是IOC容器，其实现方式是DI。</p>
<p><strong>谁控制谁，控制什么：</strong></p>
<p>传统Java  SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建。</p>
<p>IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。</p>
<p><strong>为何是反转，哪些方面反转了：</strong></p>
<p>有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；</p>
<p>为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。</p>
<p><strong>IOC（控制反转）理论推导示例</strong><br>UserDao 接口<br>UserDaoImpl 实现类<br>UserService 业务接口<br>UserServiceImpl 业务实现类</p>
<p>原来 Service中 new UserDaoImpl()，用户实际调用的是Service业务层，若想要增加一个新的UserDaoMysqlImpl实现类，需要修改Service中的new 代码。</p>
<p>使用IOC实现时，不需根据用户需求修改员来的代码。这里可以取消new，而使用set方法为 userDao 变量赋值。</p>
<p>之前程序主动创建对象，控制权在程序员手上，所以每当用户修改需求后都需要修改代码。使用set注入后，程序不再具有主动性，而是变为被动的接收对象。程序员不需要再去管理对象的创建，系统耦合性大大降低，可以专注在业务的实现上。这是IOC的原型。</p>
<p>使用面向对象编程：程序对象的依赖关系硬编码在程序中<br>控制反转：获得依赖对象的方式反转了</p>
<p><strong>IOC创建对象的方式</strong></p>
<ol>
<li>默认使用无参构造创建对象</li>
<li>使用有参构造函数时应使用<code>&lt;constructor-arg /&gt;</code>,如 <code>&lt;constructor-arg  index=&quot;0&quot; value=&quot;&quot; /&gt;</code>，或不使用index而是使用类型，参数名进行构造</li>
</ol>
<p>配置文件加载时，容器中管理的对象就已经初始化了。内存中只有一份实例，多次getBean取出的对象相同。</p>
<h3 id="Spring-IoC简介"><a href="#Spring-IoC简介" class="headerlink" title="Spring IoC简介"></a>Spring IoC简介</h3><p>Spring IoC通过一个配置文件买搜狐Bean和Bean之间的依赖关系，利用Java的反射功能实例化Bean并建立Bean之间的依赖关系。</p>
<p>Spring的Ioc容器为Spring Ioc，Spring IoC容器在完成这些底层工作的基础上，还提供了Bean实例缓存管理，Bean生命周期管理，Bean实例代理，事件发布和资源装载等高级服务。</p>
<p>Spring 提供了两种 IoC 容器，分别为 BeanFactory 和 ApplicationContext。</p>
<h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><p>BeanFactory 是基础类型的 IoC 容器，是一个管理 Bean 的工厂，它主要负责初始化各种 Bean，并调用它们的生命周期方法。</p>
<p>它有多个实现类，最常见的是 XmlBeanFactory，根据 XML 配置文件中的定义装配 Bean。</p>
<h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><p>ApplicationContext 是 BeanFactory 的子接口，也被称为应用上下文。</p>
<p>它不仅提供了 BeanFactory 的所有功能，还添加了对 i18n（国际化）、资源访问、事件传播等方面的良好支持。</p>
<p>ApplicationContext 接口有两个常用的实现类：</p>
<ul>
<li><p>ClassPathXmlApplicationContext</p>
<p>从类路径 ClassPath 中寻找指定的 XML 配置文件，找到并装载完成 ApplicationContext 的实例化工作。</p>
</li>
<li><p>FileSystemXmlApplicationContext</p>
<p>从指定的文件系统路径中寻找指定的 XML 配置文件，找到并装载完成 ApplicationContext 的实例化工作。</p>
</li>
</ul>
<p>FileSystemXmlApplicationContext 与 ClassPathXmlApplicationContext 的区别是：在读取 Spring  的配置文件时，FileSystemXmlApplicationContext  不再从类路径中读取配置文件，而是通过参数指定配置文件的位置，它可以获取类路径之外的资源，如 “F：/workspaces/applicationContext.xml”。</p>
<h3 id="BeanFactory和ApplicationContext的区别"><a href="#BeanFactory和ApplicationContext的区别" class="headerlink" title="BeanFactory和ApplicationContext的区别"></a>BeanFactory和ApplicationContext的区别</h3><h3 id="Spring-Bean的自动装配"><a href="#Spring-Bean的自动装配" class="headerlink" title="Spring Bean的自动装配"></a>Spring Bean的自动装配</h3><p>Spring可以通过向BeanFactory中注入的方式自动搞定Bean之间的依赖关系。自动装配可以设置在每个Bean上，也可以设置在特定的Bean上。</p>
<h3 id="自动装配的五种方式"><a href="#自动装配的五种方式" class="headerlink" title="自动装配的五种方式"></a>自动装配的五种方式</h3><ul>
<li>no：关闭自动装配</li>
<li>byName：通过参数名自动装配</li>
<li>byType：通过参数类型自动装配</li>
<li>constructor：通过设置构造器参数的方式来装配对象</li>
<li>autodetect：首次尝试使用constructor来自动装配，若无法完成，则采用byType方式进行装配。</li>
</ul>
<h3 id="Spring-Bean的装配流程"><a href="#Spring-Bean的装配流程" class="headerlink" title="Spring Bean的装配流程"></a>Spring Bean的装配流程</h3><p>Spring在启动是会从XML配置文件或注解中<strong>读取</strong>应用程序提供的Bean<strong>配置信息</strong></p>
<p>在Spring容器中<strong>生成</strong>一份相应的Bean配置<strong>注册表</strong>；</p>
<p>根据这张注册表<strong>实例化Bean</strong>，装配好Bean之间的依赖关系，为上层环境提供基础的运行环境。</p>
<p>其中Bean缓存池通过HashMap实现。</p>
<h3 id="Spring-Bean的作用域"><a href="#Spring-Bean的作用域" class="headerlink" title="Spring Bean的作用域"></a>Spring Bean的作用域</h3><p>Spring 为 Bean定义了五种作用域</p>
<ul>
<li>Singleton（单例）</li>
</ul>
<p>Singleton是单例模式，当实例类型为单例模式时，Spring IoC 容器中只会存在一个共享的Bean实例，无论有多少个Bean引用它，都始终指向同一个Bean对象。</p>
<p>Singleton作用域是 Spring 中的默认作用域，也可以通过配置将Bean定义为Sington模式。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alex.UserDaoImpl&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;sington&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Prototype（原型）</li>
</ul>
<p>Prototype是原型模式，每次通过Spring容器获取Prototype定义的Bean时，容器都将创建一个新的Bean实例，每个Bean实例都有自己的属性和状态，而Singleton全局只有一个对象。因此，队友状态的Bean经常使用Prototype作用域，而对无状态的Bean则使用Singleton作用域。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alex.UserService&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Request（请求级别）</li>
</ul>
<p>Request指在一次HTTP请求中容器会返回该Bean的同一个实例</p>
<ul>
<li>Session（会话级别）</li>
<li>Global Session（全局会话）</li>
</ul>
<h3 id="依赖注入（DI）"><a href="#依赖注入（DI）" class="headerlink" title="依赖注入（DI）"></a>依赖注入（DI）</h3><p>DI（Dependency  Injection，依赖注入）是指组件之间依赖关系由容器在运行期决定。形象的说，即由容器动态的将某个依赖关系注入到组件之中。</p>
<p>依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p>
<p><strong>谁依赖于谁：</strong>应用程序依赖于IoC容器。</p>
<p><strong>为什么需要依赖：</strong>应用程序需要IoC容器来提供对象需要的外部资源。</p>
<p><strong>谁注入谁：</strong>是IoC容器注入应用程序某个对象，应用程序依赖的对象。</p>
<p><strong>注入了什么：</strong>注入某个对象所需要的外部资源（包括对象、资源、常量数据）。</p>
<h3 id="Spring中的四种依赖注入"><a href="#Spring中的四种依赖注入" class="headerlink" title="Spring中的四种依赖注入"></a>Spring中的四种依赖注入</h3><p><strong>注入方式：</strong></p>
<ul>
<li>构造器注入</li>
<li>Set方式注入<br>依赖：bean对象的创建依赖于容器<br>注入：bean对象由容器注入</li>
<li>静态工厂注入</li>
<li>实例工厂注入</li>
</ul>
<p>Bean的自动装配</p>
<p>自动装配是Spring满足bean依赖的一种方式<br>Spring会在上下文中自动寻找，并自动给bean装配属性</p>
<ul>
<li>autowire</li>
<li>byname自动装配</li>
<li>byType</li>
</ul>
<p>@Autowired<br>@Qualifier(value=”cat”)</p>
<p>@Resource<br>先根据名字找，名字找不到根据类型找<br>@Resource(name=””)<br>后面可以指定name</p>
<h2 id="面向切面（AOP）"><a href="#面向切面（AOP）" class="headerlink" title="面向切面（AOP）"></a>面向切面（AOP）</h2><p>AOP（Aspect Orient Programming，面向切面编程）是一种编程思想，是面向对象编程（OOP）的一种补充。面向对象编程将程序抽象成各个层次的对象，而面向切面编程是将程序抽象成各个切面。</p>
<p>Spring AOP的主要目的是将非功能性需求从功能性需求中分离出来，达到解耦的目的。</p>
<p>AOP技术利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。</p>
<img src="E:\Document\学习笔记\图片\aop.png" alt="img" style="zoom:67%;" />

<p>所谓切面，相当于应用对象间的横切点，我们可以将其单独抽象为单独的模块。</p>
<p>静态 AOP 实现， AOP 框架在编译阶段对程序源代码进行修改，生成了静态的 AOP 代理类（生成的 *.class 文件已经被改掉了，需要使用特定的编译器），比如 AspectJ。</p>
<p>动态 AOP 实现， AOP 框架在运行阶段对动态生成代理对象（在内存中以 JDK 动态代理，或 CGlib 动态地生成 AOP 代理类），如 SpringAOP。</p>
<h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h3><p>Spring Aop 提供了 JDK 和 CGLib 两种方式来生成代理对象，具体生成代理的方式由 AopProxyFactory 根据AdvisedSupport对象的配置来决定。</p>
<p>Spring 默认的代理对象生成策略为：如果是目标类接口，则使用 JDK 动态代理技术，否则使用CGLib动态代理技术。</p>
<p><strong>Spring AOP就是基于动态代理的</strong>，如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong> ，这时候Spring AOP会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p>
<p><img src="5.Spring.assets/SpringAOPProcess.jpg" alt="SpringAOPProcess"></p>
<p>基于接口的动态代理：JDK的动态代理<br>基于类：cglib</p>
<h4 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h4><p>主要通过 java.lang.reflect 包中 Proxy 类和 InvocationHandler 接口来实现。 </p>
<p>InvocationHandler 是一个接口，不同的实现类定义不同的横切逻辑，并通过反射机制调用目标类的代码，动态地将横切逻辑和业务逻辑编制在一起。</p>
<p>Proxy类利用 InvocationHandler 动态创建一个符合某一接口的实例，生成目标类的代理对象。</p>
<h4 id="CGLib-动态代理"><a href="#CGLib-动态代理" class="headerlink" title="CGLib 动态代理"></a>CGLib 动态代理</h4><p>Code Generation Library，它是一个高性能管道代码生成类库，可以在运行期间扩展Java类和实现Java接口。</p>
<p>CGLib 包的底层通过字节码处理 ASM 来实现，通过转换字节码生成新的类。</p>
<p>CGLib 动态代理 和 JDK 动态代理的区别：JDK只能为接口创建代理实例，而对于没有通过接口定义业务方法的类，则只能通过 CGLib 创建动态来实现。</p>
<p>java字节码实现–javassist？？？</p>
<h3 id="AOP的五种通知类型"><a href="#AOP的五种通知类型" class="headerlink" title="AOP的五种通知类型"></a>AOP的五种通知类型</h3><ol>
<li><p>前置通知</p>
<p>在一个方法执行之前执行通知</p>
</li>
<li><p>后置通知</p>
<p>在一个方法执行之后执行通知</p>
</li>
<li><p>成功通知</p>
<p>在一个方法执行成功之后执行通知（只有在方法执行成功时才执行通知）</p>
</li>
<li><p>异常通知</p>
<p>当一个方法执行抛出异常退出时，才执行该通知</p>
</li>
<li><p>环绕通知</p>
<p>在拦截方法调用之前和之后，分别执行通知</p>
</li>
</ol>
<h3 id="AOP的代码实现"><a href="#AOP的代码实现" class="headerlink" title="AOP的代码实现"></a>AOP的代码实现</h3><p>通过<code>@Aspect</code>注解声明一个切面</p>
<p>通过<code>@PointCut</code>定义需要拦截的方法</p>
<p>然后通过<code>@Before</code>、<code>@AfterReturning</code>、<code>@Aroud</code>分别实现前置通知、后置通知和环绕通知要执行的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span> <span class="comment">//定义切面</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionDemo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PointCut(value=&quot;execution(* com.alex.core.service.*.*.*(..))&quot;)</span>	<span class="comment">//定义要拦截的方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">point</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before(value=&quot;point()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;transaction begin&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@AfterReturning(value=&quot;point()&quot;)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;transcation commit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Aroud(&quot;point()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aroud</span><span class="params">(ProceedingJoinPoin joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;transaction begin&quot;</span>);</span><br><span class="line">        joinPoint.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;transcation commit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Spring-MVC的原理"><a href="#Spring-MVC的原理" class="headerlink" title="Spring MVC的原理"></a>Spring MVC的原理</h2><p>MVC（Model View Controller，模型-视图-控制器）</p>
<p>该框架围绕DispatcherServlet设计</p>
<p>DispatcherServlet 会把请求分发给各个处理器，并支持可配置的处理器映射和视图渲染等功能。</p>
<p>工作流程如下：</p>
<ol>
<li><p><strong>客户端发起HTTP请求</strong></p>
<p>客户端将请求提交到 DispatcherServlet</p>
</li>
<li><p><strong>寻找处理器</strong></p>
<p>由 DispatcherServlet控制器查询一个或多个HandlerMapping，找到处理该请求的 Controller</p>
</li>
<li><p><strong>调用处理器</strong></p>
<p>DispatcherServlet 将请求提交到 Controller</p>
</li>
<li><p><strong>调用业务处理逻辑并返回结果</strong></p>
<p>Controller 调用 Service 中的业务处理逻辑后，将处理结果返回 ModelAndView。</p>
</li>
<li><p><strong>处理视图映射并返回模型</strong></p>
<p>DispatcherServlet 查询一个或多个 ViewResoler 视图解析器，找到 ModelAndView 指定的视图。</p>
</li>
<li><p><strong>HTTP响应</strong></p>
<p>视图负责将结果在客户端浏览器上渲染和展示。</p>
</li>
</ol>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务保证了用户操作的<strong>原子性</strong>（Atmoicity）、<strong>一致性</strong>（Consistency）、<strong>隔离性</strong>（Isolation）和<strong>持久性</strong>（Durability）。</p>
<p>事务分<strong>本地事务</strong>和<strong>分布式事务</strong>两种。</p>
<h3 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h3><p>本地事务基于数据库资源实现，书屋串行地在JDBC连接上执行，本地事务将事务处理局限在当前事务资源内。</p>
<p>其特点是使用灵活但无法支持多数据源事务操作。</p>
<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>分布式事务（Distributed Transcation）提供了跨数据库的分布式事务操作的数据一致性</p>
<p>跨数据库的一致性包含同一类型数据库的多个数据库实例服务的一致性（例如多个MySQL的事务一致性）和多个不同类型数据库的数据一致性（例如MySQL和Oracle之间的事务一致性）</p>
<p>Java事务编程接口（Java Transcation API，JTA）和 Java事务服务（Java Transaction Service，JTS）为J2EE平台提供了分布式事务服务。</p>
<p>分布式事务包括一个事务管理器（Trabscation Manager）和一个或多个支持XA协议的资源管理器。</p>
<p>事务管理器负责所有事务参与单元的协调域控制</p>
<p>资源管理器负责不同的数据库具体的事务执行操作。</p>
<h3 id="两段提交协议"><a href="#两段提交协议" class="headerlink" title="两段提交协议"></a>两段提交协议</h3><h2 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h2><p><strong>什么是循环依赖？</strong></p>
<p>循环依赖其实就是循环引用，也就是两个或则两个以上的bean互相持有对方，最终形成闭环。比如A依赖于B，B依赖于C，C又依赖于A。</p>
<p><strong>怎么检测循环依赖？</strong></p>
<p>Bean在创建的时候可以给该Bean打标，如果递归调用回来发现正在创建中的话，即说明了循环依赖了。</p>
<p><strong>Spring怎么解决循环依赖？</strong></p>
<p>Spring为了解决单例的循环依赖问题，使用了<strong>三级缓存</strong></p>
<p>在实例化A时调用doGetBean，发现A依赖的B的实例，此时调用doGetBean去实例B，实例化的B的时候发现又依赖A，如果不解决这个循环依赖的话此时的doGetBean将会无限循环下去，导致内存溢出，程序奔溃。spring引用了一个早期对象，并且把这个”早期引用”并将其注入到容器中，让B先完成实例化，此时A就获取B的引用，完成实例化。</p>
<p>Spring的循环依赖的理论依据其实是基于Java的引用传递，当我们获取到对象的引用时，对象的field或则属性是可以延后设置的(但是构造器必须是在获取引用之前)。</p>
<p><strong>Spring 无法解决的循环依赖问题</strong></p>
<p>Spring不能解决“A的构造方法中依赖了B的实例对象，同时B的构造方法中依赖了A的实例对象”这类问题。因为加入singletonFactories三级缓存的前提是执行了构造器，所以构造器的循环依赖没法解决。</p>
<h2 id="Spring配置"><a href="#Spring配置" class="headerlink" title="Spring配置"></a>Spring配置</h2><p><strong>别名</strong> <strong>alias</strong><br><strong>bean的配置</strong><br>id=”userT”  bean的唯一标识符相当于对象名<br>class: bean对象所对应的全限定名: 包名+类名<br>name: 也是别名，而且name可以同时取多个别名，可以通过空格或逗号分割</p>
<p><strong>import</strong><br>一般用于团队开发，将多个xml配置文件导入合并为一个配置文件，使用时直接使用总的配置就可以了<br><code>&lt;import resource=&quot;&quot;&gt;</code></p>
<p><strong>使用Java的方式配置Spring</strong><br>JavaConfig是Spring的一个子项目</p>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="spring中-Autowire和-Resource的区别"><a href="#spring中-Autowire和-Resource的区别" class="headerlink" title="spring中@Autowire和@Resource的区别"></a>spring中@Autowire和@Resource的区别</h3><h3 id="RequestBody和-ResponseBody的区别"><a href="#RequestBody和-ResponseBody的区别" class="headerlink" title="@RequestBody和@ResponseBody的区别"></a>@RequestBody和@ResponseBody的区别</h3><h3 id="Component-Service和-Repository"><a href="#Component-Service和-Repository" class="headerlink" title="@Component,@Service和@ Repository"></a>@Component,@Service和@ Repository</h3><h3 id="transactional"><a href="#transactional" class="headerlink" title="@transactional"></a>@transactional</h3><h3 id="mvc里的HandlerMapping和Handler"><a href="#mvc里的HandlerMapping和Handler" class="headerlink" title="mvc里的HandlerMapping和Handler"></a>mvc里的HandlerMapping和Handler</h3><h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="什么是-Spring-Boot"><a href="#什么是-Spring-Boot" class="headerlink" title="什么是 Spring Boot"></a>什么是 Spring Boot</h2><p>Spring Boot的设计目的是用来简化Spring应用烦琐的搭建以及开发过程。通过它只需要使用极少的配置，就可以得到一个可正常运行的应用程序。</p>
<p>Spring Boot其实并不能称之为新框架，它只是默认配置了很多常用框架（这被称为 “ 起步依赖 ” ），Spring Boot整合了大部分常用的框架（包括他们的使用方式以及常用配置）。</p>
<p>Spring Boot 的诞生给企业快速开发微小的项目提供了可能。</p>
<h2 id="Spring-Boot的优势"><a href="#Spring-Boot的优势" class="headerlink" title="Spring Boot的优势"></a>Spring Boot的优势</h2><ol>
<li>从搭建的角度看，Spring Boot可以帮助开发者快速搭建企业级应用。</li>
<li>从整合第三方框架的角度看，传统的Spring应用如果需要整合第三方框架，需要加入大量的XML配置文件，并配置很多晦涩难懂的参数；而对于Spring Boot而言，只需要加入Spring Boot内置的针对第三方的 “<strong>起步依赖</strong>“，即内置的Jar包即可，不再需要编写大量的样板代码、注释和进行繁琐的XML配置</li>
<li>从项目运行的角度看，Spring Boot<strong>内置了Servlet容器</strong>（如Tomcat），其搭建的项目可以直接打成Jar包，在安装由Java运行环境的服务器上直接运行，省去了额外安装以及配置Servlet容器的步骤，可以说非常方便。Spring Boot还能对运行中的应用进行状态的监控。</li>
<li>从开发和部署的角度看，使用Spring Boot搭建项目的<strong>代码和配置文件</strong>更少了，不需要再对第三方矿建的配置而烦恼了。项目整体来看也跟家精简，扩展性编点更强了，可更大地节约开发和维护成本。</li>
<li>由于SpringBoot是Spring家族的一员，所以对于Spring Boot应用而言，其与Spring家族的其他成员如Spring ORM、Spring JDBC、Spring Data、Spring Security等的集成非常方便、容易。</li>
</ol>
<p>简单来说，Spring Boot提供以下四个好处：</p>
<ul>
<li>使代码更加简单。</li>
<li>简化了配置。</li>
<li>使部署更加便捷。</li>
<li>使应用的监控变得更加简单和方便。</li>
</ul>
<h2 id="Spring-Boot的六个特性"><a href="#Spring-Boot的六个特性" class="headerlink" title="Spring Boot的六个特性"></a>Spring Boot的六个特性</h2><ul>
<li>遵循<strong>习惯优于配置</strong>理念，即开发项目时，只需要进行很少的配置，大部分情况下使用默认配置即可。</li>
<li>可以帮助开发者快速地搭建应用，并自动整合主流框架和大部分第三方框架，即<strong>自动装配</strong>。</li>
<li>对于应用可以不需要使用XML配置，而只需要采用<strong>自动配置</strong>或采用<strong>Java Config配置</strong>相关组件。</li>
<li>采用<strong>内置的Servlet容器</strong>，并采用简单的命令直接执行项目，可以不需要借助外置的容器便可运行。</li>
<li>整合主流框架或大部分的第三方框架时，只需要直接引入Spring Boot内置的Start Jar即可，这个特性称为 “<strong>起步依赖</strong>”，可以很方便地进行包管理。</li>
<li>Spring Boot <strong>内置了监控组件Actuator</strong>，只需要引入相应的起步依赖，就可以基于HTTP、SSH、Telnet等方式对运行中的应用进行监控。</li>
</ul>
<h2 id="为什么可以快速开发"><a href="#为什么可以快速开发" class="headerlink" title="为什么可以快速开发"></a>为什么可以快速开发</h2><h2 id="启动器里集成了哪些"><a href="#启动器里集成了哪些" class="headerlink" title="启动器里集成了哪些"></a>启动器里集成了哪些</h2><h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><p>Spring Framework最核心的功能是IOC和AOP， IoC容器的主要功能是可以管理对象的生命周期。也就是bean的管理。我们把Bean对象托管到Spring Ioc容器的这个过程称为装配。</p>
<p><img src="5.Spring.assets/2020070215205383.png" alt="在这里插入图片描述"></p>
<p> 在Spring boot框架中，我们可以不必配置xml文件，就能完成Bean注入IOC的动作。这在之前的Spring是通过xml配置来说明要装配的组件，Spring boot为了简化开发人员的配置工作，遵循 “约定大于配置，配置大于编码” 原则，</p>
<p>通过约定来实现IOC的注入，通过默认配置来代替常规的配置，从而简化了开发人员的配置和开发过程，提升研发效率。</p>
<p> 整体流程是@EnableAutoConfiguration中的实现类扫描 “classpath下即Pom依赖” 中所有包含/META-INF/spring.factories的包，并根据其xxxAutoConfiguration和/META-INF/spring-autoconfigure-metadata.properties中的条件判断来决定是否进行自动装配。</p>
<h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h3><h4 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h4><h4 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h4><p>一旦加上此注解，那么将会开启自动装配功能，简单点讲，Spring会试图在你的classpath下找到所有配置的Bean然后进行装配。当然装配Bean时，会根据若干个(Conditional)定制规则来进行初始化。</p>
<h4 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h4><p>此处@ComponentScan由于没有指定扫描包，因此它默认扫描的是与该类同级的类或者同级包下的所有类</p>
<h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><h3 id="SpringBootApplication-1"><a href="#SpringBootApplication-1" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h3><p>定义在main方法入口类处，用于启动 Sping Boot 应用项目。</p>
<h3 id="RequestMapping。。。"><a href="#RequestMapping。。。" class="headerlink" title="@RequestMapping。。。"></a>@RequestMapping。。。</h3><p>用来映射web请求(访问路径和参数)、处理类和方法，可以注解在类或方法上。</p>
<p>注解在方法上的路径会继承注解在类上的路径。</p>
<p>produces属性: 定制返回的response的媒体类型和字符集，或需返回值是json对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/demo/copper&quot;,produces=&quot;application/json;charset=UTF-8&quot;,method = RequestMethod.POST)</span></span><br></pre></td></tr></table></figure>

<h3 id="PostMapping。。。"><a href="#PostMapping。。。" class="headerlink" title="@PostMapping。。。"></a>@PostMapping。。。</h3><ul>
<li><p>类上</p>
</li>
<li><p>函数上</p>
</li>
</ul>
<h3 id="DeleteMapping。。。"><a href="#DeleteMapping。。。" class="headerlink" title="@DeleteMapping。。。"></a>@DeleteMapping。。。</h3><h3 id="GetMapping。。。"><a href="#GetMapping。。。" class="headerlink" title="@GetMapping。。。"></a>@GetMapping。。。</h3><h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h3><p>获取request请求的参数值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;CopperVO&gt; <span class="title">getOpList</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="meta">@RequestParam(value = &quot;pageIndex&quot;, required = false)</span> Integer pageIndex,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="meta">@RequestParam(value = &quot;pageSize&quot;, required = false)</span> Integer pageSize)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Param-（dao层）。。。"><a href="#Param-（dao层）。。。" class="headerlink" title="@Param （dao层）。。。"></a>@Param （dao层）。。。</h3><h3 id="RequestBody。。。"><a href="#RequestBody。。。" class="headerlink" title="@RequestBody。。。"></a>@RequestBody。。。</h3><h3 id="ResponseBody。。。"><a href="#ResponseBody。。。" class="headerlink" title="@ResponseBody。。。"></a>@ResponseBody。。。</h3><p>支持将返回值放在response体内，而不是返回一个页面。比如Ajax接口，可以用此注解返回数据而不是页面。此注解可以放置在返回值前或方法前。</p>
<h3 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(name=&quot;bean的名字&quot;,initMethod=&quot;初始化时调用方法名字&quot;,destroyMethod=&quot;close&quot;)</span></span><br></pre></td></tr></table></figure>

<p>定义在方法上，在容器内初始化一个bean实例类。</p>
<h3 id="Service"><a href="#Service" class="headerlink" title="@Service"></a>@Service</h3><p>用于标注业务层组件</p>
<h3 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h3><p>用于标注控制层组件(如struts中的action)</p>
<h3 id="Repository"><a href="#Repository" class="headerlink" title="@Repository"></a>@Repository</h3><p>用于标注数据访问组件，即DAO组件</p>
<h3 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h3><p>泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</p>
<h3 id="PostConstruct"><a href="#PostConstruct" class="headerlink" title="@PostConstruct"></a>@PostConstruct</h3><p>spring容器初始化时，要执行该方法</p>
<h3 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h3><p>用来获得请求url中的动态参数</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="Select-Insert。。。"><a href="#Select-Insert。。。" class="headerlink" title="@Select @Insert。。。"></a>@Select @Insert。。。</h3><h3 id="DateTimeFormat。。。"><a href="#DateTimeFormat。。。" class="headerlink" title="@DateTimeFormat。。。"></a>@DateTimeFormat。。。</h3><p>java.sql.TimeStamp</p>
<h3 id="Autowire。。。"><a href="#Autowire。。。" class="headerlink" title="@Autowire。。。"></a>@Autowire。。。</h3><h3 id="CrossOrigin。。。"><a href="#CrossOrigin。。。" class="headerlink" title="@CrossOrigin。。。"></a>@CrossOrigin。。。</h3><h3 id="Slf4j。。。"><a href="#Slf4j。。。" class="headerlink" title="@Slf4j。。。"></a>@Slf4j。。。</h3><h3 id="ServerEndpoint。。。"><a href="#ServerEndpoint。。。" class="headerlink" title="@ServerEndpoint。。。"></a>@ServerEndpoint。。。</h3><h3 id="Configuration。。。"><a href="#Configuration。。。" class="headerlink" title="@Configuration。。。"></a>@Configuration。。。</h3><h3 id="Value。。。"><a href="#Value。。。" class="headerlink" title="@Value。。。"></a>@Value。。。</h3><h1 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h1><h1 id="Shiro"><a href="#Shiro" class="headerlink" title="Shiro"></a>Shiro</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h2><p>Apache Shiro 是一个强大易用的 Java 安全框架，提供了认证、授权、加密和会话管理等功能，对于任何一个应用程序，Shiro 都可以提供全面的安全管理服务。</p>
<h2 id="与Spring-Security的区别"><a href="#与Spring-Security的区别" class="headerlink" title="与Spring Security的区别"></a>与Spring Security的区别</h2><p>没有 Spring Security 做的功能强大，但Shiro小而简单。</p>
<h2 id="shiro-主要功能"><a href="#shiro-主要功能" class="headerlink" title="shiro 主要功能"></a><strong>shiro 主要功能</strong></h2><p><img src=".%5C%E5%9B%BE%E7%89%87%5CSpring%5Cshiro-1.png" alt="img"></p>
<ul>
<li><strong>Authentication</strong>：身份认证/登录，验证用户是不是拥有相应的身份；</li>
<li><strong>Authorization</strong>：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限；</li>
<li><strong>Session Manager：</strong>会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通JavaSE环境的，也可以是如Web环境的；</li>
<li><strong>Cryptography</strong>：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储；</li>
<li><strong>Web Support</strong>：Web支持，可以非常容易的集成到Web环境</li>
<li><strong>Caching</strong>：缓存，比如用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可以提高效率；</li>
<li><strong>Concurrency</strong>：Shiro支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；</li>
<li><strong>Testing</strong>：提供测试支持；</li>
<li><strong>Run As</strong>：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；</li>
<li><strong>Remember Me</strong>：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。</li>
</ul>
<p><strong>Shiro的三个核心组件</strong></p>
<p><img src="https://atts.w3cschool.cn/attachments/image/wk/shiro/2.png" alt="img"></p>
<ul>
<li><p><strong>Subject</strong>，主体，即 ”当前操作用户“。Subject代表了当前用户的安全操作（需要被认证的对象）。应用代码直接交互的对象是 Subject，也就是说 Shiro 的对外 API 核心就是 Subject。</p>
<p>这个用户不一定是一个具体的人，与当前应用交互的任何东西都是  Subject，如网络爬虫，机器人等；即一个抽象概念；所有 Subject 都绑定到 SecurityManager，与 Subject  的所有交互都会委托给 SecurityManager；可以把 Subject 认为是一个门面；SecurityManager 才是实际的执行者；</p>
</li>
<li><p><strong>SecurityManager</strong></p>
<ul>
<li>它是Shiro框架的核心，管理所有用户的安全操作，并提供安全管理的各种服务。</li>
<li>管理着所有 Subject；可以看出它是 Shiro  的核心，它负责与后边介绍的其他组件进行交互，如果学习过 SpringMVC，你可以把它看成 DispatcherServlet 前端控制器；</li>
</ul>
</li>
<li><p><strong>Realm</strong>： </p>
<ul>
<li>域，Shiro 从从 Realm 获取安全数据（如用户、角色、权限），就是说 SecurityManager 要验证用户身份，那么它需要从  Realm 获取相应的用户进行比较以确定用户身份是否合法</li>
<li>也需要从 Realm 得到用户相应的角色 / 权限进行验证用户是否能进行操作</li>
<li>可以把  Realm 看成 DataSource，即安全数据源。</li>
<li>Realm充当了Shiro与应用安全数据间的“桥梁”或者“连接器”。也就是说，当对用户执行认证（登录）和授权（访问控制）验证时，Shiro会从应用配置的Realm中查找用户及其权限信息。</li>
</ul>
</li>
</ul>
<p>相关权限过滤器</p>
<ul>
<li>anon：匿名过滤器，未登陆也可以访问</li>
<li>authc：认证过滤器， 登陆后访问</li>
<li>perms：需要xx权限，才能访问</li>
<li>user：需要xx用户，才能访问</li>
<li>port：指定端口才能访问</li>
<li>ssl：必须使用https协议才能访问</li>
<li>logout：登出功能</li>
<li>rest：根据指定HTTP请求访问才能访问</li>
<li>get方式提交 或者 post方式提交才能访问</li>
</ul>
<p><strong>shiro 架构</strong></p>
<p>不管是任何请求都会经过　SecurityManager 拦截并进行相应的处理，shiro 几乎所有的功能都是由 SecurityManager 来管理。</p>
<h2 id="shiro登陆认证过程原理"><a href="#shiro登陆认证过程原理" class="headerlink" title="shiro登陆认证过程原理"></a>shiro登陆认证过程原理</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/k393393/article/details/112550976">https://blog.csdn.net/k393393/article/details/112550976</a></p>
<p>登陆请求及用户名和密码数据传到后端的 controller里后，</p>
<p>可以先获得一个subject实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Subject subject = SecurityUtils.getSubject();</span><br></pre></td></tr></table></figure>

<p>将用户名和密码信息封装成一个token</p>
<p>调用subject的login方法，该方法为Subject接口里的一个抽象方法。</p>
<p>SecurityManager会拦截者个方法的请求，并做相应的处理。</p>
<p>可以通过继承 <code>AuthorizingRealm</code> 类并重写其中的认证方法 <code>doGetAuthenticationInfo</code> 来实现登陆认证过程。</p>
<p>Subject是主体，是对外API。</p>
<p>SecurityManager是Shiro框架的核心，管理所有用户的安全操作，并提供安全管理的各种服务。</p>
<p>Realm负责从数据库中获取数据，而Shiro 从从 Realm 获取安全数据（如用户、角色、权限），就是说 SecurityManager 要验证用户身份，那么它需要从  Realm 获取相应的用户进行比较以确定用户身份是否合法。</p>
<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="防SQL注入"><a href="#防SQL注入" class="headerlink" title="防SQL注入"></a>防SQL注入</h2><p>SQL注入攻击，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。</p>
<p>具体来说，它是利用现有应用程序，将恶意的SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入特殊的恶意的SQL语句从而得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句。</p>
<p>若是在编写代码的时候，没有对用户输入数据的合法性进行判断，应用程序可能存在安全隐患。</p>
<p>传入SQL语句可控参数分为两类：</p>
<ul>
<li>数字类型，参数不用被引号括起来，如?id=1；</li>
<li>其他类型，参数要被引号扩起来，如?name=”phone”。除此之外，用户可以构造SQL语句万能密码’or 1=1#；username’#，在已知用户名的情况下，可绕过输入密码。</li>
</ul>
<p>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。</p>
<p>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</p>
<p>MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 Pojos（Plain Ordinary Java Object，普通的 Java对象)映射成数据库中的记录。</p>
<p>Mybatis启用了<strong>预编译</strong>功能，在sql语句执行前，会先将上面的sql发送给数据库进行编译，执行时，直接使用编译好的sql，替换占位符“？“就可以了。因为sql注入只能对编译过程起作用，所以这样的方式就很好地避免了sql注入的问题，其中主要是#和$的区别。</p>
<ul>
<li><p><strong># 将sql进行预编译</strong>where id = ?，然后底层再使用PreparedStatement的set方法进行参数设置。</p>
</li>
<li><p>$ 将传入的数据直接将参数拼接在sql中，比如 “where id = 123”。</p>
</li>
</ul>
<p>因此，#与$相比，#可以很大程度的防止sql注入，因为对sql做了预编译处理，因此在使用中<strong>一般使用#{}方式</strong>。</p>
<h2 id="MyBatis的缓存"><a href="#MyBatis的缓存" class="headerlink" title="MyBatis的缓存"></a>MyBatis的缓存</h2><p>MyBatis 的缓存分为一级缓存和二级缓存。默认情况下，以及缓存是开启的，而且不能被关闭。</p>
<p>一级缓存：指SqlSession级别的缓存</p>
<p>二级缓存：指跨SqlSession级别的缓存，即Mapper级别的缓存</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="GET和Post的区别"><a href="#GET和Post的区别" class="headerlink" title="GET和Post的区别"></a>GET和Post的区别</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/25/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-id="ckp3gdqgy0000poupexy426ob" data-title="Spring学习笔记" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/06/20/%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1%EF%BC%9A%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E6%A6%82%E8%BF%B0/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          数据建模：统计分析概述
        
      </div>
    </a>
  
  
    <a href="/2021/05/25/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">MySQL学习笔记</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/06/20/%E7%BB%9F%E8%AE%A1%E5%BB%BA%E6%A8%A1%EF%BC%9A%E5%88%86%E7%B1%BB%E6%80%A7%E8%83%BD%E8%AF%84%E4%BB%B7%EF%BC%88%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5%E5%92%8CROC%E6%9B%B2%E7%BA%BF%EF%BC%89/">统计建模：分类性能评价（混淆矩阵和ROC曲线）</a>
          </li>
        
          <li>
            <a href="/2021/06/20/%E7%BB%9F%E8%AE%A1%E5%BB%BA%E6%A8%A1%EF%BC%9A%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A8%A1%E5%9E%8B/">统计建模：朴素贝叶斯模型</a>
          </li>
        
          <li>
            <a href="/2021/06/20/%E7%BB%9F%E8%AE%A1%E5%BB%BA%E6%A8%A1%EF%BC%9ALogistic%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B%EF%BC%88%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%EF%BC%89/">统计建模：Logistic回归模型（逻辑回归）</a>
          </li>
        
          <li>
            <a href="/2021/06/20/%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1%EF%BC%9A%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E6%A6%82%E8%BF%B0/">数据建模：统计分析概述</a>
          </li>
        
          <li>
            <a href="/2021/05/25/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Spring学习笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 王云涛<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>