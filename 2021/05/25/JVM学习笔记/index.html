<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>JVM学习笔记 | 我的学习笔记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Java内存区域JVM 内存布局规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行。不同的 JVM 对于内存的划分方式和管理机制存在着部分差异。 Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区域，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程一一对应的数据区域会随着线程开始和结束而创建和销毁。">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM学习笔记">
<meta property="og:url" content="http://example.com/2021/05/25/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="我的学习笔记">
<meta property="og:description" content="Java内存区域JVM 内存布局规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行。不同的 JVM 对于内存的划分方式和管理机制存在着部分差异。 Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区域，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程一一对应的数据区域会随着线程开始和结束而创建和销毁。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="e:/Document/学习笔记/图片/JVM虚拟机/generation.jpg">
<meta property="og:image" content="e:/Document/学习笔记/图片/JVM虚拟机/java_jvm_classload_2.png">
<meta property="og:image" content="e:/Document/学习笔记/图片/JVM虚拟机/java_jvm_classload_1.png">
<meta property="og:image" content="e:/Document/学习笔记/图片/JVM虚拟机/java_jvm_classload_3.png">
<meta property="article:published_time" content="2021-05-25T02:27:37.000Z">
<meta property="article:modified_time" content="2021-05-25T02:29:28.378Z">
<meta property="article:author" content="王云涛">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="e:/Document/学习笔记/图片/JVM虚拟机/generation.jpg">
  
    <link rel="alternate" href="/atom.xml" title="我的学习笔记" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">我的学习笔记</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-JVM学习笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/25/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2021-05-25T02:27:37.000Z" itemprop="datePublished">2021-05-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      JVM学习笔记
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h1><p>JVM 内存布局规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行。不同的 JVM 对于内存的划分方式和管理机制存在着部分差异。</p>
<p>Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区域，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程一一对应的数据区域会随着线程开始和结束而创建和销毁。</p>
<ul>
<li><strong>线程私有</strong>：程序计数器、虚拟机栈、本地方法栈</li>
<li><strong>线程共享</strong>：堆、方法区（堆外内存，Java7的永久代，JDK8的元空间，代码缓存））</li>
</ul>
<p>Java虚拟机所管理的内存将会包括以下几个运行时数据区域</p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器（Program Counter Register，PC 寄存器）是一块较小的内存空间，可以看作是当前线程所执行的字节码的<strong>行号指示器</strong></p>
<p>PC 寄存器用来存储指向下一条指令的地址，即将要执行的指令代码。由执行引擎读取下一条指令。</p>
<ul>
<li><strong>使用PC寄存器存储字节码指令地址有什么用呢？为什么使用PC寄存器记录当前线程的执行地址呢？</strong></li>
</ul>
<p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p>
<ul>
<li><strong>PC寄存器为什么会被设定为线程私有的？</strong></li>
</ul>
<p>多线程在一个特定的时间段内只会执行其中某一个线程方法，CPU会不停的做任务切换，这样必然会导致经常中断或恢复。为了能够准确的记录各个线程正在执行的当前字节码指令地址，所以为每个线程都分配了一个PC寄存器，每个线程都独立计算，不会互相影响。</p>
<p><strong>总结</strong></p>
<ul>
<li>它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域</li>
<li>在 JVM 规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期一致</li>
<li>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。如果当前线程正在执行的是 Java 方法，程序计数器记录的是<strong>虚拟机字节码指令地址</strong>，如果是执行 <strong>native 方法</strong>，计数器值则应为<strong>空（Undefined）</strong></li>
<li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成</li>
<li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</li>
<li><strong>它是唯一一个在 JVM 规范中没有规定任何 <code>OutOfMemoryError</code> 情况的区域</strong></li>
</ul>
<h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>Java 虚拟机栈（Java Virtual Machine Stack），早期也叫 Java 栈。每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame），对应着一次次 Java 方法调用，是<strong>线程私有</strong>的，生命周期和线程一致。</p>
<p><strong>作用：</strong>虚拟机栈描述Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机会同步创建一个栈帧（Stack Frame），用于存储局部变量表、操作数栈、动态连接、方法出口等信息。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器</li>
<li>直接对虚拟机栈的操作只有两个：每个方法执被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈从入栈到出栈的过程。</li>
<li><strong>栈不存在垃圾回收问题</strong></li>
</ul>
<p><strong>存储单位</strong></p>
<ul>
<li>每个线程都有自己的栈，栈中的数据都是以<strong>栈帧（Stack Frame）的格式存在</strong></li>
<li>在这个线程上正在执行的每个方法都各自有对应的一个栈帧</li>
<li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息</li>
</ul>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p><strong>本地方法接口</strong></p>
<p>一个 Native Method 就是一个 Java 调用非 Java 代码的接口。</p>
<p>Java 使用起来非常方便，然而有些层次的任务用 Java 实现起来也不容易，或者我们对程序的效率很在意时，问题就来了</p>
<ul>
<li>与 Java 环境外交互：有时 Java 应用需要与 Java 外面的环境交互，这就是本地方法存在的原因。</li>
<li>与操作系统交互：JVM 支持 Java 语言本身和运行时库，但是有时仍需要依赖一些底层系统的支持。通过本地方法，我们可以实现用 Java 与实现了 jre 的底层系统交互， JVM 的一些部分就是 C 语言写的。</li>
<li>Sun’s Java：Sun的解释器就是C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分都是用 Java 实现的，它也通过一些本地方法与外界交互。比如，类 <code>java.lang.Thread</code> 的 <code>setPriority()</code> 的方法是用Java 实现的，但它实现调用的是该类的本地方法 <code>setPrioruty()</code>，该方法是C实现的，并被植入 JVM 内部。</li>
</ul>
<p><strong>本地方法栈（Native Method Stack）</strong></p>
<p>Java 虚拟机栈用于管理 Java 方法的调用，而本地方法栈用于管理本地方法的调用</p>
<p>本地方法栈也是<strong>线程私有</strong>的</p>
<p>允许线程固定或者可动态扩展的内存大小</p>
<ul>
<li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java 虚拟机将会抛出一个 <code>StackOverflowError</code> 异常</li>
<li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么 Java虚拟机将会抛出一个<code>OutofMemoryError</code>异常</li>
</ul>
<p>本地方法是使用 C 语言实现的</p>
<p>它的具体做法是 <code>Mative Method Stack</code> 中登记 native 方法，在 <code>Execution Engine</code> 执行时加载本地方法库当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</p>
<p>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区，它甚至可以直接使用本地处理器中的寄存器，直接从本地内存的堆中分配任意数量的内存</p>
<p>并不是所有 JVM 都支持本地方法。因为 Java 虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果 JVM 产品不打算支持 native 方法，也;可以无需实现本地方法栈</p>
<p>在 Hotspot JVM 中，直接将本地方栈和虚拟机栈合二为一</p>
<h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><blockquote>
<p><strong>栈是运行时的单位，而堆是存储的单位</strong>。</p>
<p>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪。</p>
</blockquote>
<p>对于大多数应用，Java 堆是 Java 虚拟机管理的<strong>内存最大的一块</strong>，被<strong>所有线程共享</strong>，在<strong>虚拟机启动时创建</strong>。此内存区域的唯一目的就是<strong>存放对象实例</strong>，几乎所有的对象实例以及数据都在这里分配内存。</p>
<p>Java堆是垃圾收集器管理的内存区域，因此也被称作 <strong>GC堆</strong>。</p>
<p>如果堆中没有完成实例分配，并且堆无法再扩展时，就会抛出 <code>OutOfMemoryError</code> 异常。</p>
<p>为了进行高效的垃圾回收，虚拟机把堆内存<strong>逻辑上</strong>划分成三块区域（分代的唯一理由就是优化 GC 性能）：</p>
<ul>
<li>新生带（年轻代）：新对象和没达到一定年龄的对象都在新生代</li>
<li>老年代（养老区）：被长时间使用的对象，老年代的内存空间应该要比年轻代更大</li>
<li>元空间（JDK1.8 之前叫永久代）：像一些方法中的操作临时对象等，JDK1.8 之前是占用 JVM 内存，JDK1.8 之后直接使用物理内存</li>
</ul>
<p>Java 虚拟机规范规定，Java 堆可以是处于物理上不连续的内存空间中，只要逻辑上是连续的即可，像磁盘空间一样。实现时，既可以是固定大小，也可以是可扩展的，主流虚拟机都是可扩展的（通过 <code>-Xmx</code> 和 <code>-Xms</code> 控制）。</p>
<p><strong>为什么堆区会引起线程安全的问题？用什么方法去避免这些问题</strong> </p>
<p>堆是所有线程共享的一片公用内存区域。对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己 的栈，如果多个线程使用该变量就可能引发问题，这时volatile 变量就可以发挥作用了，它要求线程从主存中读取变量的值。</p>
<p><strong>年轻代 (Young Generation)</strong></p>
<p>年轻代是所有新对象创建的地方。当填充年轻代时，执行垃圾收集。这种垃圾收集称为 <strong>Minor GC</strong>。年轻一代被分为三个部分——伊甸园（<strong>Eden Memory</strong>）和两个幸存区（<strong>Survivor Memory</strong>，被称为from/to或s0/s1），默认比例是<code>8:1:1</code></p>
<ul>
<li>大多数新创建的对象都位于 Eden 内存空间中</li>
<li>当 Eden 空间被对象填充时，执行<strong>Minor GC</strong>，并将所有幸存者对象移动到一个幸存者空间中</li>
<li>Minor GC 检查幸存者对象，并将它们移动到另一个幸存者空间。所以每次，一个幸存者空间总是空的</li>
<li>经过多次 GC 循环后存活下来的对象被移动到老年代。通常，这是通过设置年轻一代对象的年龄阈值来实现的，然后他们才有资格提升到老一代</li>
</ul>
<p><strong>老年代(Old Generation)</strong></p>
<p>旧的一代内存包含那些经过许多轮小型 GC 后仍然存活的对象。通常，垃圾收集是在老年代内存满时执行的。老年代垃圾收集称为 主GC（Major GC），通常需要更长的时间。</p>
<p>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在 Eden 区和两个Survivor 区之间发生大量的内存拷贝</p>
<p><img src="E:\Document\学习笔记\图片\JVM虚拟机\generation.jpg" alt="img"></p>
<p><strong>元空间</strong></p>
<p>不管是 JDK8 之前的永久代，还是 JDK8 及以后的元空间，都可以看作是 Java 虚拟机规范中方法区的实现。</p>
<p>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap（非堆），目的应该是与 Java 堆区分开。</p>
<p>所以元空间放在后边的方法区再说。</p>
<p><strong>对象在堆中的生命周期</strong></p>
<ol>
<li>在 JVM 内存模型的堆中，堆被划分为新生代和老年代<ul>
<li>新生代又被进一步划分为 <strong>Eden区</strong> 和 <strong>Survivor区</strong>，Survivor 区由 <strong>From Survivor</strong> 和 <strong>To Survivor</strong> 组成</li>
</ul>
</li>
<li>当创建一个对象时，对象会被优先分配到新生代的 Eden 区<ul>
<li>此时 JVM 会给对象定义一个<strong>对象年轻计数器</strong>（<code>-XX:MaxTenuringThreshold</code>）</li>
</ul>
</li>
<li>当 Eden 空间不足时，JVM 将执行新生代的垃圾回收（Minor GC）<ul>
<li>JVM 会把存活的对象转移到 Survivor 中，并且对象年龄 +1</li>
<li>对象在 Survivor 中同样也会经历 Minor GC，每经历一次 Minor GC，对象年龄都会+1</li>
</ul>
</li>
<li>如果分配的对象超过了<code>-XX:PetenureSizeThreshold</code>，对象会<strong>直接被分配到老年代</strong> </li>
</ol>
<p><strong>对象的分配过程</strong></p>
<p>为对象分配内存是一件非常严谨和复杂的任务，JVM 的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法和内存回收算法密切相关，所以还需要考虑 GC 执行完内存回收后是否会在内存空间中产生内存碎片。</p>
<ol>
<li>new 的对象先放在伊甸园区，此区有大小限制</li>
<li>当伊甸园的空间填满时，程序又需要创建对象，JVM 的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</li>
<li>然后将伊甸园中的剩余对象移动到幸存者 0 区</li>
<li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者 0 区，如果没有回收，就会放到幸存者 1 区</li>
<li>如果再次经历垃圾回收，此时会重新放回幸存者 0 区，接着再去幸存者 1 区</li>
<li>什么时候才会去养老区呢？ 默认是 15 次回收标记</li>
<li>在养老区，相对悠闲。当养老区内存不足时，再次触发 Major GC，进行养老区的内存清理</li>
<li>若养老区执行了 Major GC  之后发现依然无法进行对象的保存，就会产生 OOM 异常</li>
</ol>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><ul>
<li>方法区（Method Area）与 Java 堆一样，是所有<strong>线程共享</strong>的内存区域。</li>
<li>用于加载已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</li>
<li>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap（非堆），目的应该是与 Java 堆区分开。</li>
<li>方法区的大小和堆空间一样，可以选择固定大小也可选择可扩展，方法区的大小决定了系统可以放多少个类，如果系统类太多，导致方法区溢出，虚拟机同样会抛出内存溢出错误</li>
<li>JVM 关闭后方法区即被释放</li>
<li>该区域的回收目标主要是针对常量池的回收和对类型的卸载。</li>
</ul>
<p><strong>为什么去永久代？讲下内存泄漏的一些原因</strong></p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a><strong>运行时常量池</strong></h3><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。</p>
<p>Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是<strong>常量池表</strong>（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p>
<p>运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的是 <code>String.intern()</code>方法。受方法区内存的限制，当常量池无法再申请到内存时会抛出 <code>OutOfMemoryErro</code>r 异常。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存（Direct Memory）不是虚拟机运行时数据区的一部分。</p>
<h1 id="HotSpot-虚拟机中的对象"><a href="#HotSpot-虚拟机中的对象" class="headerlink" title="HotSpot 虚拟机中的对象"></a>HotSpot 虚拟机中的对象</h1><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p><strong>1. 类加载检查过程</strong></p>
<p>Java 虚拟机遇到一条 new 指令，检查这个指令的参数是否能在常量池中定位到一个类的符号引用。</p>
<ul>
<li><p>如果能定位到，检查这个符号引用代表的类是否已被加载、解析和初始化过；</p>
</li>
<li><p>如果没有检查到，就必须先执行相应的类加载过程；</p>
</li>
</ul>
<p><strong>2. 分配内存</strong></p>
<p>对象所需内存的大小在类加载完成后便完全确定（Java虚拟机可以通过普通Java对象的类元数据信息确定对象大小）</p>
<p>为对象分配内存相当于把一块确定大小的内存从Java堆里划分出来；</p>
<p><strong>3.初始化为零值，必要的设置</strong></p>
<p>对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码对象的GC分代年龄等信息。这些信息存放在对象的对象头中。</p>
<p><strong>4.构造函数</strong></p>
<p>执行Class文件中的<code>&lt;init&gt;()</code>方法，按照程序员的意愿对对象进行初始化。</p>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>对象头</p>
<p>实例数据</p>
<p>对齐填充</p>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>使用句柄</p>
<p>直接访问</p>
<h1 id="垃圾收集（Garbage-Collection，GC）"><a href="#垃圾收集（Garbage-Collection，GC）" class="headerlink" title="垃圾收集（Garbage Collection，GC）"></a>垃圾收集（Garbage Collection，GC）</h1><p>垃圾回收：释放垃圾占用的空间</p>
<p>当一个对象不再被需要时，该对象就需要被回收并释放空间</p>
<p>Java内存运行时数据区域</p>
<ul>
<li>程序计数器，线程私有</li>
<li>虚拟机栈，线程私有</li>
<li>本地方法栈，线程私有</li>
<li>堆</li>
</ul>
<h2 id="判断对象是否可回收"><a href="#判断对象是否可回收" class="headerlink" title="判断对象是否可回收"></a><strong>判断对象是否可回收</strong></h2><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>给每个对象添加引用计数器，为0即为可回收的对象</p>
<h3 id="根搜索算法（主流商用语言使用）"><a href="#根搜索算法（主流商用语言使用）" class="headerlink" title="根搜索算法（主流商用语言使用）"></a>根搜索算法（主流商用语言使用）</h3><p>从若干被称为GC Roots 的对象开始进行搜索，不能到达的对象即为可回收的对象</p>
<p>Java中，GC Roots一般包含下面几种对象：</p>
<ul>
<li><p>虚拟机中引用的对象</p>
</li>
<li><p>本地方法栈中的本地方法引用的对象</p>
</li>
<li><p>方法区中的类静态属性引用的对象</p>
</li>
<li><p>方法区中的常量引用的对象</p>
</li>
<li><p>引用的分类</p>
<ul>
<li>强引用 代码中普遍存在的引用  垃圾回收器不会回收被强引用关联的对象</li>
<li>软引用 有用但非必须的对象 系统将要发生内存溢出异常时，回收 <code>SoftReference</code>类</li>
<li>弱引用 非必须的对象 被弱引用关联的对象只能存活到下一次垃圾回收之前，当垃圾回收器工作时，被弱引用关联的对象一定会被回收 WeakReference</li>
<li>虚引用 最弱  一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，唯一目的就是能在这个对象被回收时收到一个系统通知。PhantomReference</li>
</ul>
</li>
</ul>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a><strong>垃圾收集算法</strong></h2><h3 id="引用计数式垃圾收集"><a href="#引用计数式垃圾收集" class="headerlink" title="引用计数式垃圾收集"></a>引用计数式垃圾收集</h3><p>（Reference Counting GC，直接垃圾收集）</p>
<h3 id="追踪式垃圾收集"><a href="#追踪式垃圾收集" class="headerlink" title="追踪式垃圾收集"></a>追踪式垃圾收集</h3><p>（Tracing GC，间接垃圾收集）</p>
<h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>算法分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象</p>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这块内存需要进行垃圾回收时，会将此区域还存活着的对象复制到另一块上面，然后再把已经使用过的内存区域一次清理掉。</p>
<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>复制收集算法在对象存活率较高时会进行比较多的复制操作，效率会变低。因此在老年代一般不能使用复制算法。</p>
<p>针对老年代的特点，提出了一种称之为“标记-整理算法”。</p>
<p>标记过程仍与“标记-清除”过程一致，但后续步骤不是直接对可回收对象进行清理，而是让所有存活对象向一端移动，然后直接清理掉端边界以外的内存。</p>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>根据对象存活周期的不同将内存划分为几块。</p>
<p> 一般是把Java堆分为新生代和老年代。</p>
<p>在新生代中，每次垃圾回收都有大批对象死去，只有少量存活，因此我们采用复制算法；</p>
<p>而老年代中对象存活率高、没有额外空间对它进行分配担保，就必须采用”标记-清理”或者”标记-整理”算法。</p>
<p><strong>分代收集理论</strong></p>
<h2 id="Minor-GC和Full-GC的区别："><a href="#Minor-GC和Full-GC的区别：" class="headerlink" title="Minor GC和Full GC的区别："></a>Minor GC和Full GC的区别：</h2><ul>
<li>Minor GC（新生代GC）：指的是发生在新生代的垃圾收集。因为Java对象大多都具备朝生夕灭的特性，因此Minor GC（采用复制算法）非常频繁，一般回收速度也比较快。</li>
<li>Full GC（老年代GC，Major GC）：指发生在老年代的垃圾收集。出现了Major GC，经常会伴随至少一次的Minor GC（并非绝对，在Parallel Scavenge收集器中就有直接进行Full GC的策略选择过程</li>
</ul>
<h2 id="调用垃圾回收器的方法"><a href="#调用垃圾回收器的方法" class="headerlink" title="调用垃圾回收器的方法"></a><strong>调用垃圾回收器的方法</strong></h2><p>调用垃圾回收的方法是gc</p>
<p>java.lang.System.gc 等价于 java.lang.Runtime.getRuntime.gc 的简写</p>
<p>在 Runtime 中 gc 是实例方法</p>
<p>在 System 中 gc 是静态方法，该方法调用Runtime类中的gc方法</p>
<h2 id="finalize方法"><a href="#finalize方法" class="headerlink" title="finalize方法"></a><strong>finalize方法</strong></h2><p>在Object类中定义，释放对象占用的内存之前调用</p>
<p>默认不做任何实现</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>新生代收集器：Serail、ParNew、Parallel Sacvenge</p>
<p>老年代收集器：Serail Old、CMS、Parallel Old</p>
<p>面向堆内存任何部分来组成回收集（并不是面向整个堆Full GC）：Garbage First</p>
<h3 id="经典垃圾收集器"><a href="#经典垃圾收集器" class="headerlink" title="经典垃圾收集器"></a>经典垃圾收集器</h3><h4 id="Serial-垃圾收集器"><a href="#Serial-垃圾收集器" class="headerlink" title="Serial 垃圾收集器"></a><strong>Serial 垃圾收集器</strong></h4><p>是基础的，历史最悠久的收集器</p>
<p>单线程工作的收集器</p>
<p>在它进行垃圾收集时，必须暂停其他所有工作线程，直至它收集结束。“ Stop The World ”</p>
<p>HotSpot 虚拟机在客户端模式下的默认新生代收集器。</p>
<p>优势：简单而高效。额外内存消耗最小。</p>
<h4 id="ParNew-垃圾收集器"><a href="#ParNew-垃圾收集器" class="headerlink" title="ParNew 垃圾收集器"></a><strong>ParNew 垃圾收集器</strong></h4><p>Serail收集器的多线程并行版本</p>
<p>除了Serail收集器外，目前只有它能与CMS收集器配合工作。</p>
<p>是激活CMS后的默认新生代收集器</p>
<p>-XX:+/UseParNewGC</p>
<p>默认开启的收集线程数与处理器核心数量相同。</p>
<h4 id="Parallel-Seavenge-收集器"><a href="#Parallel-Seavenge-收集器" class="headerlink" title="Parallel Seavenge 收集器"></a><strong>Parallel Seavenge 收集器</strong></h4><p>新生代收集器，基于标记-复制算法实现，并行收集的多线程收集器。</p>
<p>特点：目标是达到一个可控制的吞吐量。</p>
<p>被称作 “ 吞吐量优先收集器 ”。</p>
<h4 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a><strong>Serial Old 收集器</strong></h4><p>Serail 收集器的老年代版本，单线程收集器，使用标记-整理算法。</p>
<h4 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a><strong>Parallel Old 收集器</strong></h4><p>Parallel Seavenge收集器的老年版本，支持多线程并发收集，基于标记-整理算法。</p>
<h4 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a><strong>CMS 收集器</strong></h4><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短挥手停顿时间为目标的收集器，基于<strong>标记-清除</strong>算法。（sweep：打扫，清扫），目前很大一部分的 Java 应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的相应速度。</p>
<p>整个过程分为四个步骤：</p>
<ol>
<li><p><strong>初始标记</strong>（CMS initial mark）</p>
<p>仅标记以下GC Roots能直接关联到的对象，速度很快。</p>
</li>
<li><p><strong>并发标记</strong>（CMS concurrent mark）</p>
<p>从GC Roots的直接关联对象开始遍历整个对象图的过程，耗时较长但不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</p>
</li>
<li><p><strong>重新标记</strong>（CMS remark）</p>
<p>修正并发标记期间因用户程序继续运作而导致标记产生表动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</p>
</li>
<li><p><strong>并发清除</strong>（CMS concurrent sweep）</p>
<p>清理删除掉标记阶段判断的已经死亡的对象</p>
<p>由于不需要移动存活对象，这个阶段也是可以与用户线程同时并发的。</p>
</li>
</ol>
<p>三个明显的<strong>缺点</strong>：</p>
<ol>
<li><p>对处理器资源非常敏感，在并发阶段，它虽然不会导致用户线程停顿，但会因为占用了一部分线程（或者说处理器的计算能力）而导致应用程序变慢，降低吞吐量。</p>
<p>CMS 默认启动的回收线程数是（处理器核心数量+3）/ 4。处理器核心数量不足四个时，影响会变得很大。</p>
</li>
<li><p>无法处理 “ 浮动垃圾 ”，可能会出现 “Concurrent Mode Failure（并发模式故障）” 失败而导致另一次完全 “ Stop The Word” 的 Full GC 产生。</p>
</li>
<li><p>收集结束时会有大量空间碎片产生。</p>
<p>CMS是一款“标记–清除”算法实现的收集器，容易出现大量空间碎片。</p>
<p>当空间碎片过多，将会给大对象分配带来很大的麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。</p>
</li>
</ol>
<h4 id="Garbage-First-收集器（G1）"><a href="#Garbage-First-收集器（G1）" class="headerlink" title="Garbage First 收集器（G1）"></a><strong>Garbage First 收集器（G1）</strong></h4><p>G1是一款面向服务端应用的垃圾收集器。它开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。</p>
<p>从 JDK9 开始成为服务段模式下的默认垃圾收集器。</p>
<p><strong>停顿时间模型</strong>（Pause Prediction Model）：在一个长度位M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒。</p>
<p><strong>Mixed GC模式：</strong>可以面向堆内存任何部分来组成回收集（Collection Set，一般简称CSet）进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器<strong>Mixed GC模式</strong>。</p>
<p><strong>基于Region的堆内存布局：</strong></p>
<p>G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。</p>
<p><strong>Humongous区域：</strong></p>
<p>Region中的一类特殊区域，专门用来存储大对象。</p>
<p>G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。</p>
<p>对于超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中。</p>
<p>G1中的大多数行为都把Humongous Region作为老年代的一部分看待。</p>
<p><strong>价值：</strong></p>
<p>价值即回收所获得的空间大小以及回收所需时间的经验值</p>
<p>G1收集器跟踪各个Region里面的垃圾堆积的<strong>价值</strong>大小，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间优先处理回收价值最大的那些Region。（收集停顿时间可使用参数<code>XX:MaxGCPauseMillis</code>指定，默认值是200毫秒）。</p>
<p><strong>G1收集器的运作过程：</strong></p>
<p>G1收集器的运作过程大致可划分为以下四个步骤：</p>
<ol>
<li><strong>初始标记</strong>（Initial Marking）： 仅仅是标记一些GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的 Region 中分配新的对象。</li>
<li><strong>并发标记</strong>（Concurrent Marking）： 从GC Roots开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象。耗时较长，但可与用户线程并发执行。</li>
<li><strong>最终标记</strong>（Final Marking）： 对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。</li>
<li><strong>筛选回收</strong>（Live Data Counting and Evacuation）： 负责更新Region的统计数量，对各个Region进行回收价值和成本排序，根据用户期望的停顿时间制定回收计划，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧的Region的全部空间。</li>
</ol>
<p><strong>G1收集器解决的关键细节问题：</strong>、</p>
<ul>
<li><strong>Region里面的跨Region引用对象如何解决？</strong></li>
<li><strong>在并发标记阶段如何保证收集线程与用户线程互不干扰的运行？</strong></li>
<li><strong>怎样建立起可靠的停顿模型？</strong></li>
</ul>
<h4 id="G1与CMS的比较"><a href="#G1与CMS的比较" class="headerlink" title="G1与CMS的比较"></a>G1与CMS的比较</h4><p>G1的优点：</p>
<ul>
<li><p>可以指定最大停顿时间</p>
</li>
<li><p>分Region的内存布局</p>
</li>
<li><p>按收益动态确定回收集</p>
</li>
<li><p>CMS采用 “ 标记-清除算法 ”，G1从整体上看是基于 “ 标记-整理算法 ”，从局部（两个Region之间）上看又是基于 “ 标记-复制 ” 算法的。这两种算法意味着G1运作期间<strong>不会产生内存空间碎片</strong>，垃圾收集完成后能提供完整的可用内存。这种特性有利于程序长时间运行，在程序为大对象分配内存时不容易因无法找到连续内存空间而提前触发下一次收集。</p>
</li>
</ul>
<p>G1的弱项：</p>
<ul>
<li>在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footpring）还是程序运行时的额外负载（Overload）都要比CMS高。</li>
<li>G1的卡表实现更为复杂</li>
<li>G1对写屏障的复杂操作要比CMS消耗更多的运算资源。</li>
</ul>
<p><strong>CMS和G1应用场景：</strong></p>
<p>小内存应用上CMS的表现大概率仍然由于G1</p>
<p>大内存应用上G1大多能发挥其优势</p>
<p>这个Java堆容量平衡点通常在6GB至8GB之间。</p>
<h3 id="低延迟垃圾收集器"><a href="#低延迟垃圾收集器" class="headerlink" title="低延迟垃圾收集器"></a>低延迟垃圾收集器</h3><p>Shenandoah 收集器</p>
<p>ZGC收集器</p>
<h3 id="垃圾收集器的选择"><a href="#垃圾收集器的选择" class="headerlink" title="垃圾收集器的选择"></a>垃圾收集器的选择</h3><h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p>其中类加载的过程包括了<strong>加载、验证、准备、解析、初始化</strong>五个阶段</p>
<p>在这五个阶段中，加载、验证、准备、和初始化这四个阶段发生的顺序是确定的，而<strong>解析</strong>阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定(也称为动态绑定或晚期绑定)。</p>
<p><img src="E:\Document\学习笔记\图片\JVM虚拟机\java_jvm_classload_2.png" alt="img"></p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情:</p>
<ul>
<li><p>通过一个类的全限定名来获取其定义的二进制字节流。</p>
</li>
<li><p>将这个字节流所代表的静态存储结构转化为<strong>方法区</strong>的运行时数据结构。</p>
</li>
<li><p>在Java<strong>堆</strong>中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</p>
</li>
</ul>
<p><img src="E:\Document\学习笔记\图片\JVM虚拟机\java_jvm_classload_1.png" alt="img"></p>
<p>相对于类加载的其他阶段而言，加载阶段(准确地说，是加载阶段获取类的二进制字节流的动作)是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p>
<p>类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误(LinkageError错误)如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p>
<p><strong>加载.class文件的方式</strong></p>
<ul>
<li>从本地系统中直接加载</li>
<li>通过网络下载.class文件</li>
<li>从zip，jar等归档文件中加载.class文件</li>
<li>从专有数据库中提取.class文件</li>
<li>将Java源文件动态编译为.class文件</li>
</ul>
<h3 id="连接（验证，准备，解析）"><a href="#连接（验证，准备，解析）" class="headerlink" title="连接（验证，准备，解析）"></a>连接（验证，准备，解析）</h3><p><strong>验证</strong></p>
<p>验证是连接阶段的第一步，目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用<code>-Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<p>该阶段大致会完成4个阶段的检验动作:</p>
<ul>
<li>文件格式验证: 验证字节流是否符合Class文件格式的规范；例如: 是否以<code>0xCAFEBABE</code>开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li>
<li>元数据验证: 对字节码描述的信息进行语义分析(注意: 对比<code>javac</code>编译阶段的语义分析)，以保证其描述的信息符合Java语言规范的要求；例如: 这个类是否有父类，除了<code>java.lang.Object</code>之外。</li>
<li>字节码验证: 通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li>
<li>符号引用验证: 确保解析动作能正确执行。</li>
</ul>
<p><strong>准备</strong></p>
<p>该阶段为正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在<strong>方法区</strong>中分配。</p>
<p>这时候进行内存分配的仅包括类变量(<code>static</code>)，而<strong>不包括实例变量</strong>，实例变量会在对象实例化时随着对象一块分配在Java堆中。</p>
<p>这里所设置的初始值通常情况下是数据类型默认的零值(如<code>0</code>、<code>0L</code>、<code>null</code>、<code>false</code>等)，而不是被在Java代码中被显式地赋予的值。</p>
<p>假设一个类变量的定义为: <code>public static int value = 3</code>；那么变量value在准备阶段过后的初始值为<code>0</code>，而不是<code>3</code>，因为这时候尚未开始执行任何Java方法，而把value赋值为3的<code>put static</code>指令是在程序编译后，存放于类构造器<code>&lt;clinit&gt;()</code>方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。</p>
<ul>
<li>对基本数据类型来说，对于类变量(static)和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</li>
<li>对于同时被<code>static</code>和<code>final</code>修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</li>
<li>对于引用数据类型<code>reference</code>来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即<code>null</code>。</li>
<li>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</li>
<li>如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。假设上面的类变量value被定义为: <code>public static final int value = 3；</code>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。我们可以理解为<code>static final</code>常量在编译期就将其结果放入了调用它的类的常量池中</li>
</ul>
<p><strong>解析</strong></p>
<p>是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<p>解析动作主要针对<code>类</code>或<code>接口</code>、<code>字段</code>、<code>类方法</code>、<code>接口方法</code>、<code>方法类型</code>、<code>方法句柄</code>和<code>调用点</code>限定符7类符号引用进行。</p>
<p>符号引用就是一组符号来描述目标，可以是任何字面量，直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式:</p>
<ul>
<li>声明类变量时指定初始值</li>
<li>使用静态代码块为类变量指定初始值</li>
</ul>
<p><strong>JVM初始化步骤</strong></p>
<ul>
<li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li>
<li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li>
<li>假如类中有初始化语句，则系统依次执行这些初始化语句</li>
</ul>
<p><strong>类初始化时机</strong>: 只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种:</p>
<ul>
<li>创建类的实例，也就是new的方式</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射(如Class.forName(“com.pdai.jvm.Test”))</li>
<li>初始化某个类的子类，则其父类也会被初始化</li>
<li>Java虚拟机启动时被标明为启动类的类(Java Test)，直接使用java.exe命令来运行某个主类</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>类访问方法区内的数据结构的接口， 对象是堆(Heap)区的数据。</p>
<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p><strong>Java虚拟机将结束生命周期的几种情况</strong></p>
<ul>
<li>执行了System.exit()方法</li>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止</li>
<li>由于操作系统出现错误而导致Java虚拟机进程终止</li>
</ul>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p><strong>类加载器的层次</strong></p>
<p><img src="E:\Document\学习笔记\图片\JVM虚拟机\java_jvm_classload_3.png" alt="img"></p>
<p>注意: 这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的。</p>
<p><strong>类加载器分类</strong></p>
<p>站在Java虚拟机的角度来讲，只存在两种不同的类加载器: </p>
<ul>
<li>启动类加载器: 它使用C++实现(这里仅限于<code>Hotspot</code>，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的)，是虚拟机自身的一部分。</li>
<li>所有其他的类加载器: 这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类<code>java.lang.ClassLoader</code>，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</li>
</ul>
<p>站在Java开发人员的角度来看，类加载器可以大致划分为以下三类 :</p>
<ul>
<li>启动类加载器: Bootstrap ClassLoader，负责加载存放在 ”JDK\jre\lib“ (JDK代表JDK的安装目录)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库(如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载)。启动类加载器是无法被Java程序直接引用的。</li>
<li>扩展类加载器: Extension ClassLoader，该加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库(如javax.*开头的类)，开发者可以直接使用扩展类加载器。</li>
<li>应用程序类加载器: Application ClassLoader，该类加载器由<code>sun.misc.Launcher$AppClassLoader</code>来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ul>
<p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点:</p>
<ul>
<li>在执行非置信代码之前，自动验证数字签名。</li>
<li>动态地创建符合用户特定需要的定制化构建类。</li>
<li>从特定的场所取得java class，例如数据库中和网络中。</li>
</ul>
<p><strong>寻找类加载器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pdai.jvm.classloader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassLoader loader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        System.out.println(loader);</span><br><span class="line">        System.out.println(loader.getParent());</span><br><span class="line">        System.out.println(loader.getParent().getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@64fef26a</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@1ddd40f3</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<p>从上面的结果可以看出，并没有获取到<code>ExtClassLoader</code>的父Loader，原因是<code>BootstrapLoader</code>(引导类加载器)是用C语言实现的，找不到一个确定的返回父Loader的方式，于是就返回<code>null</code>。</p>
<p><strong>类加载的方式</strong></p>
<ul>
<li><p>命令行启动应用时候由JVM初始化加载</p>
</li>
<li><p>通过Class.forName()方法动态加载</p>
</li>
<li><p>通过ClassLoader.loadClass()方法动态加载</p>
</li>
</ul>
<p><strong>Class.forName()和ClassLoader.loadClass()区别?</strong></p>
<ul>
<li>Class.forName(): 将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</li>
<li>ClassLoader.loadClass(): 只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</li>
<li>Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。</li>
</ul>
<p><strong>自定义类加载器</strong></p>
<h2 id="JVM类加载机制"><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h2><p><strong>全盘负责</strong></p>
<p>当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显式使用另外一个类加载器来载入。</p>
<p><strong>父类委托</strong></p>
<p>先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。</p>
<p><strong>缓存机制</strong></p>
<p>缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效。</p>
<p><strong>双亲委派机制</strong></p>
<p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到<strong>顶层的启动类加载器</strong>中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p>
<ol>
<li>当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。 </li>
<li>当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。 </li>
<li>如果BootStrapClassLoader加载失败(例如在$JAVA_HOME/jre/lib里未查找到该class)，会使用ExtClassLoader来尝试加载。</li>
<li>若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。</li>
</ol>
<p><strong>双亲委派优势</strong></p>
<ul>
<li>Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系。通过这种层级关系可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。</li>
<li>保证Java程序安全稳定运行。Java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。</li>
</ul>
<p><strong>能不能自己写个类叫java.lang.System？</strong></p>
<blockquote>
<p>答案：通常不可以，但可以采取另类方法达到这个需求。<br>解释：为了不让我们写System类，类加载采用委托机制，这样可以保证爸爸们优先，爸爸们能找到的类，儿子就没有机会加载。而System类是Bootstrap加载器加载的，就算自己重写，也总是使用Java系统提供的System，自己写的System类根本没有机会得到加载。</p>
<p>但是，我们可以自己定义一个类加载器来达到这个目的，为了避免双亲委托机制，这个类加载器也必须是特殊的。由于系统自带的三个类加载器都加载特定目录下的类，如果我们自己的类加载器放在一个特殊的目录，那么系统的加载器就无法加载，也就是最终还是由我们自己的加载器加载。</p>
</blockquote>
<p><strong>关于双亲委派引申的一些框架</strong></p>
<p>Tomcat</p>
<h1 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h1><ul>
<li>Major GC的速度一般会比Minor GC慢10倍以上。</li>
</ul>
<h1 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h1><p>逃逸分析是Java虚拟机中的一种编译器优化技术，不直接优化代码。</p>
<p><strong>基本原理：</strong></p>
<p>分析对象的动态作用域</p>
<p>当一个对象在方法里被定义后，它可能被外部方法所引用，例如作为参数传递到其他方法中，这种称为<strong>方法逃逸</strong>；</p>
<p>甚至还有可能被外部线程访问到，譬如赋值给其他线程中访问到的实例变量，这种称为<strong>线程逃逸</strong>；</p>
<p><strong>优化：</strong></p>
<ul>
<li><p><strong>栈上分配：</strong></p>
<p>如果确定一个对象不会逃逸出线程之外，那可以让这个对象在栈上分配内存，对象所占用的内存空间可以随栈帧出栈而销毁。</p>
<p>栈上分配支持方法逃逸，不支持线程逃逸。</p>
</li>
<li><p><strong>标量替换：</strong></p>
<p>若一个数据已无法再分解成更小的数据来表示了，那么这些数据就可以称为<strong>标量</strong>，如Java虚拟机中原始数据类型（int，long等数值类型及reference类型）。</p>
<p>如果一个数据可以继续分解，那它就被称为<strong>聚合量</strong>。</p>
<p>如果一个数据可以把一个Java对象拆散，根据程序访问的情况，将其用到的成员变量恢复为原始类型来访问，这个过程就称为<strong>标量替换</strong>。</p>
<p>假如逃逸分析能够证明一个对象不会被方法外部访问，并且这个对象可以被拆散，那么程序执行时可能不去创建这个对象，而改为直接创建它的若干个被这个方法使用的成员变量来代替，让对象的成员变量在栈上分配和读写。</p>
<p><strong>标量替换可以视作栈上分配的一种特例</strong></p>
<p>标量替换不允许对象逃逸出方法范围内。</p>
</li>
<li><p><strong>同步消除：</strong></p>
<p>如果同步逃逸分析能够确定一个变量不会逃逸出线程，即无法被其他线程访问，那么这个变量的读写就不会有竞争，对这个变量实施的同步措施也就可以安全地消除掉。</p>
</li>
</ul>
<h1 id="即时编译器"><a href="#即时编译器" class="headerlink" title="即时编译器"></a>即时编译器</h1><p>目前主流的两款商用Java虚拟机（HotSpot、OpenJ9）里，Java程序最初都是通过<strong>解释器</strong>进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁，就会把这些代码认定为 “ <strong>热点代码</strong> ”，为了提高热点代码的执行效率，在运行时，虚拟机就会把这些代码编译成本地机器码，并以各种手段尽可能地进行代码优化，运行完成这个任务的后端编译器被称为<strong>即时编译器</strong>。</p>
<h1 id="Java虚拟机的启动"><a href="#Java虚拟机的启动" class="headerlink" title="Java虚拟机的启动"></a>Java虚拟机的启动</h1><p>操作系统装入 JVM，是通过jdk中Java.exe来完成的</p>
<p>1.创建 JVM 装载环境和配置</p>
<p>2.装载 JVM.dll</p>
<p>3.初始化 JVM.dll并挂界到 JNIENV（JNI调用接口）实例</p>
<p>4.调用 JNIEnv 实例装载并处理class类。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/25/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-id="ckp3gdqh60001poup8t200aho" data-title="JVM学习笔记" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/05/25/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          MySQL学习笔记
        
      </div>
    </a>
  
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/06/20/%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1%EF%BC%9A%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E6%A6%82%E8%BF%B0/">数据建模：统计分析概述</a>
          </li>
        
          <li>
            <a href="/2021/05/25/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Spring学习笔记</a>
          </li>
        
          <li>
            <a href="/2021/05/25/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">MySQL学习笔记</a>
          </li>
        
          <li>
            <a href="/2021/05/25/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">JVM学习笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 王云涛<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>